{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _extends from \"@babel/runtime/helpers/extends\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React from 'react';\nimport findNodeHandle from \"react-native-web/dist/exports/findNodeHandle\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport ReanimatedEventEmitter from \"./ReanimatedEventEmitter\";\nimport AnimatedEvent from \"./reanimated1/core/AnimatedEvent\";\nimport AnimatedNode from \"./reanimated1/core/AnimatedNode\";\nimport AnimatedValue from \"./reanimated1/core/AnimatedValue\";\nimport { createOrReusePropsNode } from \"./reanimated1/core/AnimatedProps\";\nimport WorkletEventHandler from \"./reanimated2/WorkletEventHandler\";\nimport setAndForwardRef from \"./setAndForwardRef\";\nimport \"./reanimated2/layoutReanimation/LayoutAnimationRepository\";\nimport invariant from 'invariant';\nimport { adaptViewConfig } from \"./ConfigHelper\";\nimport { RNRenderer } from \"./reanimated2/platform-specific/RNRenderer\";\nimport { makeMutable, runOnUI, enableLayoutAnimations } from \"./reanimated2/core\";\nimport { DefaultEntering, DefaultExiting, DefaultLayout } from \"./reanimated2/layoutReanimation/defaultAnimations/Default\";\nimport { isJest, isChromeDebugger, shouldBeUseWeb } from \"./reanimated2/PlatformChecker\";\nimport { initialUpdaterRun } from \"./reanimated2/animation\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nvar NODE_MAPPING = new Map();\n\nfunction listener(data) {\n  var component = NODE_MAPPING.get(data.viewTag);\n  component && component._updateFromNative(data.props);\n}\n\nfunction dummyListener() {}\n\nfunction hasAnimatedNodes(value) {\n  if (value instanceof AnimatedNode) {\n    return true;\n  }\n\n  if (Array.isArray(value)) {\n    return value.some(function (item) {\n      return hasAnimatedNodes(item);\n    });\n  }\n\n  if (value && typeof value === 'object') {\n    return Object.keys(value).some(function (key) {\n      return hasAnimatedNodes(value[key]);\n    });\n  }\n\n  return false;\n}\n\nfunction flattenArray(array) {\n  if (!Array.isArray(array)) {\n    return [array];\n  }\n\n  var resultArr = [];\n\n  var _flattenArray = function _flattenArray(arr) {\n    arr.forEach(function (item) {\n      if (Array.isArray(item)) {\n        _flattenArray(item);\n      } else {\n        resultArr.push(item);\n      }\n    });\n  };\n\n  _flattenArray(array);\n\n  return resultArr;\n}\n\nfunction onlyAnimatedStyles(styles) {\n  return styles.filter(function (style) {\n    return style === null || style === void 0 ? void 0 : style.viewDescriptors;\n  });\n}\n\nfunction isSameAnimatedStyle(style1, style2) {\n  return (style1 === null || style1 === void 0 ? void 0 : style1.viewsRef) === (style2 === null || style2 === void 0 ? void 0 : style2.viewsRef);\n}\n\nvar isSameAnimatedProps = isSameAnimatedStyle;\n\nvar has = function has(key, x) {\n  if (typeof x === 'function' || typeof x === 'object') {\n    if (x === null || x === undefined) {\n      return false;\n    } else {\n      return key in x;\n    }\n  }\n\n  return false;\n};\n\nexport default function createAnimatedComponent(Component, options) {\n  invariant(typeof Component !== 'function' || Component.prototype && Component.prototype.isReactComponent, '`createAnimatedComponent` does not support stateless functional components; ' + 'use a class component instead.');\n\n  var AnimatedComponent = function (_React$Component) {\n    _inherits(AnimatedComponent, _React$Component);\n\n    var _super = _createSuper(AnimatedComponent);\n\n    function AnimatedComponent(props) {\n      var _this;\n\n      _classCallCheck(this, AnimatedComponent);\n\n      _this = _super.call(this, props);\n      _this._invokeAnimatedPropsCallbackOnMount = false;\n      _this._styles = null;\n      _this._viewTag = -1;\n      _this._isFirstRender = true;\n      _this.animatedStyle = {\n        value: {}\n      };\n      _this._component = null;\n\n      _this._animatedPropsCallback = function () {\n        if (_this._component == null) {\n          _this._invokeAnimatedPropsCallbackOnMount = true;\n        } else if (typeof _this._component.setNativeProps !== 'function') {\n          _this.forceUpdate();\n        } else {\n          _this._component.setNativeProps(_this._propsAnimated.__getValue());\n        }\n      };\n\n      _this._setComponentRef = setAndForwardRef({\n        getForwardedRef: function getForwardedRef() {\n          return _this.props.forwardedRef;\n        },\n        setLocalRef: function setLocalRef(ref) {\n          var tag = findNodeHandle(ref);\n\n          if ((_this.props.layout || _this.props.entering || _this.props.exiting) && tag != null) {\n            if (!shouldBeUseWeb()) {\n              enableLayoutAnimations(true, false);\n            }\n\n            var layout = _this.props.layout ? _this.props.layout : DefaultLayout;\n            var entering = _this.props.entering ? _this.props.entering : DefaultEntering;\n            var exiting = _this.props.exiting ? _this.props.exiting : DefaultExiting;\n\n            if (has('build', layout)) {\n              layout = layout.build();\n            }\n\n            if (has('build', entering)) {\n              entering = entering.build();\n            }\n\n            if (has('build', exiting)) {\n              exiting = exiting.build();\n            }\n\n            var config = {\n              layout: layout,\n              entering: entering,\n              exiting: exiting,\n              sv: _this.sv\n            };\n            runOnUI(function () {\n              var _f = function _f() {\n                global.LayoutAnimationRepository.registerConfig(tag, config);\n              };\n\n              _f._closure = {\n                tag: tag,\n                config: config\n              };\n              _f.asString = \"function _f(){const{tag,config}=jsThis._closure;{global.LayoutAnimationRepository.registerConfig(tag,config);}}\";\n              _f.__workletHash = 5455589887771;\n              _f.__location = \"/Users/mas/Documents/perso/expo-splashscreen-generator/node_modules/react-native-reanimated/lib/createAnimatedComponent.js (148:32)\";\n\n              global.__reanimatedWorkletInit(_f);\n\n              return _f;\n            }())();\n          }\n\n          if (ref !== _this._component) {\n            _this._component = ref;\n          }\n        }\n      });\n\n      _this._attachProps(_this.props);\n\n      if (isJest()) {\n        _this.animatedStyle = {\n          value: {}\n        };\n      }\n\n      _this.sv = makeMutable({});\n      return _this;\n    }\n\n    _createClass(AnimatedComponent, [{\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        this._detachPropUpdater();\n\n        this._propsAnimated && this._propsAnimated.__detach();\n\n        this._detachNativeEvents();\n\n        this._detachStyles();\n\n        this.sv = null;\n      }\n    }, {\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        if (this._invokeAnimatedPropsCallbackOnMount) {\n          this._invokeAnimatedPropsCallbackOnMount = false;\n\n          this._animatedPropsCallback();\n        }\n\n        this._propsAnimated && this._propsAnimated.setNativeView(this._component);\n\n        this._attachNativeEvents();\n\n        this._attachPropUpdater();\n\n        this._attachAnimatedStyles();\n      }\n    }, {\n      key: \"_getEventViewRef\",\n      value: function _getEventViewRef() {\n        var _a;\n\n        return ((_a = this._component) === null || _a === void 0 ? void 0 : _a.getScrollableNode) ? this._component.getScrollableNode() : this._component;\n      }\n    }, {\n      key: \"_attachNativeEvents\",\n      value: function _attachNativeEvents() {\n        var node = this._getEventViewRef();\n\n        var viewTag = findNodeHandle((options === null || options === void 0 ? void 0 : options.setNativeProps) ? this : node);\n\n        for (var key in this.props) {\n          var prop = this.props[key];\n\n          if (prop instanceof AnimatedEvent) {\n            prop.attachEvent(node, key);\n          } else if (has('current', prop) && prop.current instanceof WorkletEventHandler) {\n            prop.current.registerForEvents(viewTag, key);\n          }\n        }\n      }\n    }, {\n      key: \"_detachNativeEvents\",\n      value: function _detachNativeEvents() {\n        var node = this._getEventViewRef();\n\n        for (var key in this.props) {\n          var prop = this.props[key];\n\n          if (prop instanceof AnimatedEvent) {\n            prop.detachEvent(node, key);\n          } else if (has('current', prop) && prop.current instanceof WorkletEventHandler) {\n            prop.current.unregisterFromEvents();\n          }\n        }\n      }\n    }, {\n      key: \"_detachStyles\",\n      value: function _detachStyles() {\n        var _a;\n\n        if (Platform.OS === 'web' && this._styles !== null) {\n          for (var _iterator = _createForOfIteratorHelperLoose(this._styles), _step; !(_step = _iterator()).done;) {\n            var style = _step.value;\n\n            if (style === null || style === void 0 ? void 0 : style.viewsRef) {\n              style.viewsRef.remove(this);\n            }\n          }\n        } else if (this._viewTag !== -1 && this._styles !== null) {\n          for (var _iterator2 = _createForOfIteratorHelperLoose(this._styles), _step2; !(_step2 = _iterator2()).done;) {\n            var _style = _step2.value;\n\n            _style.viewDescriptors.remove(this._viewTag);\n          }\n\n          if ((_a = this.props.animatedProps) === null || _a === void 0 ? void 0 : _a.viewDescriptors) {\n            this.props.animatedProps.viewDescriptors.remove(this._viewTag);\n          }\n        }\n      }\n    }, {\n      key: \"_reattachNativeEvents\",\n      value: function _reattachNativeEvents(prevProps) {\n        var node = this._getEventViewRef();\n\n        var attached = new Set();\n        var nextEvts = new Set();\n        var viewTag;\n\n        for (var key in this.props) {\n          var prop = this.props[key];\n\n          if (prop instanceof AnimatedEvent) {\n            nextEvts.add(prop.__nodeID);\n          } else if (has('current', prop) && prop.current instanceof WorkletEventHandler) {\n            if (viewTag === undefined) {\n              viewTag = prop.current.viewTag;\n            }\n          }\n        }\n\n        for (var _key in prevProps) {\n          var _prop = this.props[_key];\n\n          if (_prop instanceof AnimatedEvent) {\n            if (!nextEvts.has(_prop.__nodeID)) {\n              _prop.detachEvent(node, _key);\n            } else {\n              attached.add(_prop.__nodeID);\n            }\n          } else if (has('current', _prop) && _prop.current instanceof WorkletEventHandler && _prop.current.reattachNeeded) {\n            _prop.current.unregisterFromEvents();\n          }\n        }\n\n        for (var _key2 in this.props) {\n          var _prop2 = this.props[_key2];\n\n          if (_prop2 instanceof AnimatedEvent && !attached.has(_prop2.__nodeID)) {\n            _prop2.attachEvent(node, _key2);\n          } else if (has('current', _prop2) && _prop2.current instanceof WorkletEventHandler && _prop2.current.reattachNeeded) {\n            _prop2.current.registerForEvents(viewTag, _key2);\n\n            _prop2.current.reattachNeeded = false;\n          }\n        }\n      }\n    }, {\n      key: \"_attachProps\",\n      value: function _attachProps(nextProps) {\n        var oldPropsAnimated = this._propsAnimated;\n        this._propsAnimated = createOrReusePropsNode(nextProps, this._animatedPropsCallback, oldPropsAnimated);\n\n        if (oldPropsAnimated !== this._propsAnimated) {\n          oldPropsAnimated && oldPropsAnimated.__detach();\n        }\n      }\n    }, {\n      key: \"_updateFromNative\",\n      value: function _updateFromNative(props) {\n        var _a, _b;\n\n        if (options === null || options === void 0 ? void 0 : options.setNativeProps) {\n          options.setNativeProps(this._component, props);\n        } else {\n          (_b = (_a = this._component) === null || _a === void 0 ? void 0 : _a.setNativeProps) === null || _b === void 0 ? void 0 : _b.call(_a, props);\n        }\n      }\n    }, {\n      key: \"_attachPropUpdater\",\n      value: function _attachPropUpdater() {\n        var viewTag = findNodeHandle(this);\n        NODE_MAPPING.set(viewTag, this);\n\n        if (NODE_MAPPING.size === 1) {\n          ReanimatedEventEmitter.addListener('onReanimatedPropsChange', listener);\n        }\n      }\n    }, {\n      key: \"_attachAnimatedStyles\",\n      value: function _attachAnimatedStyles() {\n        var _this2 = this;\n\n        var _a, _b, _c;\n\n        var styles = this.props.style ? onlyAnimatedStyles(flattenArray(this.props.style)) : [];\n        var prevStyles = this._styles;\n        this._styles = styles;\n        var prevAnimatedProps = this._animatedProps;\n        this._animatedProps = this.props.animatedProps;\n        var viewTag;\n        var viewName;\n\n        if (Platform.OS === 'web') {\n          viewTag = findNodeHandle(this);\n          viewName = null;\n        } else {\n          var hostInstance = RNRenderer.findHostInstance_DEPRECATED(this);\n\n          if (!hostInstance) {\n            throw new Error('Cannot find host instance for this component. Maybe it renders nothing?');\n          }\n\n          viewTag = hostInstance === null || hostInstance === void 0 ? void 0 : hostInstance._nativeTag;\n          viewName = (_a = hostInstance === null || hostInstance === void 0 ? void 0 : hostInstance.viewConfig) === null || _a === void 0 ? void 0 : _a.uiViewClassName;\n          var hasReanimated2Props = ((_b = this.props.animatedProps) === null || _b === void 0 ? void 0 : _b.viewDescriptors) || styles.length;\n\n          if (hasReanimated2Props && (hostInstance === null || hostInstance === void 0 ? void 0 : hostInstance.viewConfig)) {\n            adaptViewConfig(hostInstance.viewConfig);\n          }\n        }\n\n        this._viewTag = viewTag;\n\n        if (prevStyles) {\n          var hasOneSameStyle = styles.length === 1 && prevStyles.length === 1 && isSameAnimatedStyle(styles[0], prevStyles[0]);\n\n          if (!hasOneSameStyle) {\n            var _loop = function _loop(prevStyle) {\n              var isPresent = styles.some(function (style) {\n                return isSameAnimatedStyle(style, prevStyle);\n              });\n\n              if (!isPresent) {\n                prevStyle.viewDescriptors.remove(viewTag);\n              }\n            };\n\n            for (var _iterator3 = _createForOfIteratorHelperLoose(prevStyles), _step3; !(_step3 = _iterator3()).done;) {\n              var prevStyle = _step3.value;\n\n              _loop(prevStyle);\n            }\n          }\n        }\n\n        styles.forEach(function (style) {\n          style.viewDescriptors.add({\n            tag: viewTag,\n            name: viewName\n          });\n\n          if (isJest()) {\n            _this2.animatedStyle.value = _extends(_extends({}, _this2.animatedStyle.value), style.initial.value);\n            style.animatedStyle.current = _this2.animatedStyle;\n          }\n        });\n\n        if (prevAnimatedProps && !isSameAnimatedProps(prevAnimatedProps, this.props.animatedProps)) {\n          prevAnimatedProps.viewDescriptors.remove(viewTag);\n        }\n\n        if ((_c = this.props.animatedProps) === null || _c === void 0 ? void 0 : _c.viewDescriptors) {\n          this.props.animatedProps.viewDescriptors.add({\n            tag: viewTag,\n            name: viewName\n          });\n        }\n      }\n    }, {\n      key: \"_detachPropUpdater\",\n      value: function _detachPropUpdater() {\n        var viewTag = findNodeHandle(this);\n        NODE_MAPPING.delete(viewTag);\n\n        if (NODE_MAPPING.size === 0) {\n          ReanimatedEventEmitter.removeAllListeners('onReanimatedPropsChange');\n        }\n      }\n    }, {\n      key: \"componentDidUpdate\",\n      value: function componentDidUpdate(prevProps) {\n        this._attachProps(this.props);\n\n        this._reattachNativeEvents(prevProps);\n\n        this._propsAnimated && this._propsAnimated.setNativeView(this._component);\n\n        this._attachAnimatedStyles();\n      }\n    }, {\n      key: \"_filterNonAnimatedStyle\",\n      value: function _filterNonAnimatedStyle(inputStyle) {\n        var style = {};\n\n        for (var key in inputStyle) {\n          var value = inputStyle[key];\n\n          if (!hasAnimatedNodes(value)) {\n            style[key] = value;\n          } else if (value instanceof AnimatedValue) {\n            style[key] = value._startingValue;\n          }\n        }\n\n        return style;\n      }\n    }, {\n      key: \"_filterNonAnimatedProps\",\n      value: function _filterNonAnimatedProps(inputProps) {\n        var _this3 = this;\n\n        var props = {};\n\n        var _loop2 = function _loop2(key) {\n          var value = inputProps[key];\n\n          if (key === 'style') {\n            var styleProp = inputProps.style;\n            var styles = flattenArray(styleProp !== null && styleProp !== void 0 ? styleProp : []);\n            var processedStyle = styles.map(function (style) {\n              if (style && style.viewDescriptors) {\n                style.viewsRef.add(_this3);\n\n                if (_this3._isFirstRender) {\n                  return _extends(_extends({}, style.initial.value), initialUpdaterRun(style.initial.updater));\n                } else {\n                  return style.initial.value;\n                }\n              } else {\n                return style;\n              }\n            });\n            props[key] = _this3._filterNonAnimatedStyle(StyleSheet.flatten(processedStyle));\n          } else if (key === 'animatedProps') {\n            var animatedProp = inputProps.animatedProps;\n\n            if (animatedProp.initial !== undefined) {\n              Object.keys(animatedProp.initial.value).forEach(function (key) {\n                var _a, _b;\n\n                props[key] = (_a = animatedProp.initial) === null || _a === void 0 ? void 0 : _a.value[key];\n                (_b = animatedProp.viewsRef) === null || _b === void 0 ? void 0 : _b.add(_this3);\n              });\n            }\n          } else if (value instanceof AnimatedEvent) {\n            props[key] = dummyListener;\n          } else if (has('current', value) && value.current instanceof WorkletEventHandler) {\n            if (value.current.eventNames.length > 0) {\n              value.current.eventNames.forEach(function (eventName) {\n                props[eventName] = has('listeners', value.current) ? value.current.listeners[eventName] : dummyListener;\n              });\n            } else {\n              props[key] = dummyListener;\n            }\n          } else if (!(value instanceof AnimatedNode)) {\n            if (key !== 'onGestureHandlerStateChange' || !isChromeDebugger()) {\n              props[key] = value;\n            }\n          } else if (value instanceof AnimatedValue) {\n            props[key] = value._startingValue;\n          }\n        };\n\n        for (var key in inputProps) {\n          _loop2(key);\n        }\n\n        return props;\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var props = this._filterNonAnimatedProps(this.props);\n\n        if (isJest()) {\n          props.animatedStyle = this.animatedStyle;\n        }\n\n        if (this._isFirstRender) {\n          this._isFirstRender = false;\n        }\n\n        var platformProps = Platform.select({\n          web: {},\n          default: {\n            collapsable: false\n          }\n        });\n        return _jsx(Component, _objectSpread(_objectSpread({}, props), {}, {\n          ref: this._setComponentRef\n        }, platformProps));\n      }\n    }]);\n\n    return AnimatedComponent;\n  }(React.Component);\n\n  AnimatedComponent.displayName = \"AnimatedComponent(\" + (Component.displayName || Component.name || 'Component') + \")\";\n  return React.forwardRef(function (props, ref) {\n    return _jsx(AnimatedComponent, _objectSpread(_objectSpread({}, props), ref === null ? null : {\n      forwardedRef: ref\n    }));\n  });\n}","map":{"version":3,"sources":["/Users/mas/Documents/perso/expo-splashscreen-generator/node_modules/react-native-reanimated/lib/createAnimatedComponent.js"],"names":["React","ReanimatedEventEmitter","AnimatedEvent","AnimatedNode","AnimatedValue","createOrReusePropsNode","WorkletEventHandler","setAndForwardRef","invariant","adaptViewConfig","RNRenderer","makeMutable","runOnUI","enableLayoutAnimations","DefaultEntering","DefaultExiting","DefaultLayout","isJest","isChromeDebugger","shouldBeUseWeb","initialUpdaterRun","NODE_MAPPING","Map","listener","data","component","get","viewTag","_updateFromNative","props","dummyListener","hasAnimatedNodes","value","Array","isArray","some","item","Object","keys","key","flattenArray","array","resultArr","_flattenArray","arr","forEach","push","onlyAnimatedStyles","styles","filter","style","viewDescriptors","isSameAnimatedStyle","style1","style2","viewsRef","isSameAnimatedProps","has","x","undefined","createAnimatedComponent","Component","options","prototype","isReactComponent","AnimatedComponent","_invokeAnimatedPropsCallbackOnMount","_styles","_viewTag","_isFirstRender","animatedStyle","_component","_animatedPropsCallback","setNativeProps","forceUpdate","_propsAnimated","__getValue","_setComponentRef","getForwardedRef","forwardedRef","setLocalRef","ref","tag","findNodeHandle","layout","entering","exiting","build","config","sv","global","LayoutAnimationRepository","registerConfig","_attachProps","_detachPropUpdater","__detach","_detachNativeEvents","_detachStyles","setNativeView","_attachNativeEvents","_attachPropUpdater","_attachAnimatedStyles","_a","getScrollableNode","node","_getEventViewRef","prop","attachEvent","current","registerForEvents","detachEvent","unregisterFromEvents","Platform","OS","remove","animatedProps","prevProps","attached","Set","nextEvts","add","__nodeID","reattachNeeded","nextProps","oldPropsAnimated","_b","call","set","size","addListener","_c","prevStyles","prevAnimatedProps","_animatedProps","viewName","hostInstance","findHostInstance_DEPRECATED","Error","_nativeTag","viewConfig","uiViewClassName","hasReanimated2Props","length","hasOneSameStyle","prevStyle","isPresent","name","initial","delete","removeAllListeners","_reattachNativeEvents","inputStyle","_startingValue","inputProps","styleProp","processedStyle","map","updater","_filterNonAnimatedStyle","StyleSheet","flatten","animatedProp","eventNames","eventName","listeners","_filterNonAnimatedProps","platformProps","select","web","default","collapsable","displayName","forwardRef"],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA,OAAOA,KAAP,MAAkB,OAAlB;;;;AAEA,OAAOC,sBAAP;AAEA,OAAOC,aAAP;AAEA,OAAOC,YAAP;AAEA,OAAOC,aAAP;AAEA,SAASC,sBAAT;AACA,OAAOC,mBAAP;AACA,OAAOC,gBAAP;AACA;AACA,OAAOC,SAAP,MAAsB,WAAtB;AACA,SAASC,eAAT;AACA,SAASC,UAAT;AACA,SAASC,WAAT,EAAsBC,OAAtB,EAA+BC,sBAA/B;AACA,SAASC,eAAT,EAA0BC,cAA1B,EAA0CC,aAA1C;AACA,SAASC,MAAT,EAAiBC,gBAAjB,EAAmCC,cAAnC;AACA,SAASC,iBAAT;;AACA,IAAMC,YAAY,GAAG,IAAIC,GAAJ,EAArB;;AACA,SAASC,QAAT,CAAkBC,IAAlB,EAAwB;AACpB,MAAMC,SAAS,GAAGJ,YAAY,CAACK,GAAb,CAAiBF,IAAI,CAACG,OAAtB,CAAlB;AACAF,EAAAA,SAAS,IAAIA,SAAS,CAACG,iBAAV,CAA4BJ,IAAI,CAACK,KAAjC,CAAb;AACH;;AACD,SAASC,aAAT,GAAyB,CAGxB;;AACD,SAASC,gBAAT,CAA0BC,KAA1B,EAAiC;AAC7B,MAAIA,KAAK,YAAY7B,YAArB,EAAmC;AAC/B,WAAO,IAAP;AACH;;AACD,MAAI8B,KAAK,CAACC,OAAN,CAAcF,KAAd,CAAJ,EAA0B;AACtB,WAAOA,KAAK,CAACG,IAAN,CAAW,UAACC,IAAD;AAAA,aAAUL,gBAAgB,CAACK,IAAD,CAA1B;AAAA,KAAX,CAAP;AACH;;AACD,MAAIJ,KAAK,IAAI,OAAOA,KAAP,KAAiB,QAA9B,EAAwC;AACpC,WAAOK,MAAM,CAACC,IAAP,CAAYN,KAAZ,EAAmBG,IAAnB,CAAwB,UAACI,GAAD;AAAA,aAASR,gBAAgB,CAACC,KAAK,CAACO,GAAD,CAAN,CAAzB;AAAA,KAAxB,CAAP;AACH;;AACD,SAAO,KAAP;AACH;;AACD,SAASC,YAAT,CAAsBC,KAAtB,EAA6B;AACzB,MAAI,CAACR,KAAK,CAACC,OAAN,CAAcO,KAAd,CAAL,EAA2B;AACvB,WAAO,CAACA,KAAD,CAAP;AACH;;AACD,MAAMC,SAAS,GAAG,EAAlB;;AACA,MAAMC,aAAa,GAAG,SAAhBA,aAAgB,CAACC,GAAD,EAAS;AAC3BA,IAAAA,GAAG,CAACC,OAAJ,CAAY,UAACT,IAAD,EAAU;AAClB,UAAIH,KAAK,CAACC,OAAN,CAAcE,IAAd,CAAJ,EAAyB;AACrBO,QAAAA,aAAa,CAACP,IAAD,CAAb;AACH,OAFD,MAGK;AACDM,QAAAA,SAAS,CAACI,IAAV,CAAeV,IAAf;AACH;AACJ,KAPD;AAQH,GATD;;AAUAO,EAAAA,aAAa,CAACF,KAAD,CAAb;;AACA,SAAOC,SAAP;AACH;;AACD,SAASK,kBAAT,CAA4BC,MAA5B,EAAoC;AAChC,SAAOA,MAAM,CAACC,MAAP,CAAc,UAACC,KAAD;AAAA,WAAWA,KAAK,KAAK,IAAV,IAAkBA,KAAK,KAAK,KAAK,CAAjC,GAAqC,KAAK,CAA1C,GAA8CA,KAAK,CAACC,eAA/D;AAAA,GAAd,CAAP;AACH;;AACD,SAASC,mBAAT,CAA6BC,MAA7B,EAAqCC,MAArC,EAA6C;AAGzC,SAAO,CAACD,MAAM,KAAK,IAAX,IAAmBA,MAAM,KAAK,KAAK,CAAnC,GAAuC,KAAK,CAA5C,GAAgDA,MAAM,CAACE,QAAxD,OAAuED,MAAM,KAAK,IAAX,IAAmBA,MAAM,KAAK,KAAK,CAAnC,GAAuC,KAAK,CAA5C,GAAgDA,MAAM,CAACC,QAA9H,CAAP;AACH;;AACD,IAAMC,mBAAmB,GAAGJ,mBAA5B;;AACA,IAAMK,GAAG,GAAG,SAANA,GAAM,CAAClB,GAAD,EAAMmB,CAAN,EAAY;AACpB,MAAI,OAAOA,CAAP,KAAa,UAAb,IAA2B,OAAOA,CAAP,KAAa,QAA5C,EAAsD;AAClD,QAAIA,CAAC,KAAK,IAAN,IAAcA,CAAC,KAAKC,SAAxB,EAAmC;AAC/B,aAAO,KAAP;AACH,KAFD,MAGK;AACD,aAAOpB,GAAG,IAAImB,CAAd;AACH;AACJ;;AACD,SAAO,KAAP;AACH,CAVD;;AAWA,eAAe,SAASE,uBAAT,CAAiCC,SAAjC,EAA4CC,OAA5C,EAAqD;AAChEtD,EAAAA,SAAS,CAAC,OAAOqD,SAAP,KAAqB,UAArB,IACLA,SAAS,CAACE,SAAV,IAAuBF,SAAS,CAACE,SAAV,CAAoBC,gBADvC,EAC0D,iFAC/D,gCAFK,CAAT;;AADgE,MAI1DC,iBAJ0D;AAAA;;AAAA;;AAK5D,+BAAYpC,KAAZ,EAAmB;AAAA;;AAAA;;AACf,gCAAMA,KAAN;AACA,YAAKqC,mCAAL,GAA2C,KAA3C;AACA,YAAKC,OAAL,GAAe,IAAf;AACA,YAAKC,QAAL,GAAgB,CAAC,CAAjB;AACA,YAAKC,cAAL,GAAsB,IAAtB;AACA,YAAKC,aAAL,GAAqB;AAAEtC,QAAAA,KAAK,EAAE;AAAT,OAArB;AACA,YAAKuC,UAAL,GAAkB,IAAlB;;AAMA,YAAKC,sBAAL,GAA8B,YAAM;AAChC,YAAI,MAAKD,UAAL,IAAmB,IAAvB,EAA6B;AAMzB,gBAAKL,mCAAL,GAA2C,IAA3C;AACH,SAPD,MAQK,IAAI,OAAO,MAAKK,UAAL,CAAgBE,cAAvB,KAA0C,UAA9C,EAA0D;AAC3D,gBAAKC,WAAL;AACH,SAFI,MAGA;AAED,gBAAKH,UAAL,CAAgBE,cAAhB,CAA+B,MAAKE,cAAL,CAAoBC,UAApB,EAA/B;AACH;AACJ,OAhBD;;AAiBA,YAAKC,gBAAL,GAAwBtE,gBAAgB,CAAC;AACrCuE,QAAAA,eAAe,EAAE;AAAA,iBAAM,MAAKjD,KAAL,CAAWkD,YAAjB;AAAA,SADoB;AAErCC,QAAAA,WAAW,EAAE,qBAACC,GAAD,EAAS;AAElB,cAAMC,GAAG,GAAGC,cAAc,CAACF,GAAD,CAA1B;;AACA,cAAI,CAAC,MAAKpD,KAAL,CAAWuD,MAAX,IAAqB,MAAKvD,KAAL,CAAWwD,QAAhC,IAA4C,MAAKxD,KAAL,CAAWyD,OAAxD,KACAJ,GAAG,IAAI,IADX,EACiB;AACb,gBAAI,CAAC/D,cAAc,EAAnB,EAAuB;AACnBN,cAAAA,sBAAsB,CAAC,IAAD,EAAO,KAAP,CAAtB;AACH;;AACD,gBAAIuE,MAAM,GAAG,MAAKvD,KAAL,CAAWuD,MAAX,GAAoB,MAAKvD,KAAL,CAAWuD,MAA/B,GAAwCpE,aAArD;AACA,gBAAIqE,QAAQ,GAAG,MAAKxD,KAAL,CAAWwD,QAAX,GACT,MAAKxD,KAAL,CAAWwD,QADF,GAETvE,eAFN;AAGA,gBAAIwE,OAAO,GAAG,MAAKzD,KAAL,CAAWyD,OAAX,GACR,MAAKzD,KAAL,CAAWyD,OADH,GAERvE,cAFN;;AAGA,gBAAI0C,GAAG,CAAC,OAAD,EAAU2B,MAAV,CAAP,EAA0B;AACtBA,cAAAA,MAAM,GAAGA,MAAM,CAACG,KAAP,EAAT;AACH;;AACD,gBAAI9B,GAAG,CAAC,OAAD,EAAU4B,QAAV,CAAP,EAA4B;AACxBA,cAAAA,QAAQ,GAAGA,QAAQ,CAACE,KAAT,EAAX;AACH;;AACD,gBAAI9B,GAAG,CAAC,OAAD,EAAU6B,OAAV,CAAP,EAA2B;AACvBA,cAAAA,OAAO,GAAGA,OAAO,CAACC,KAAR,EAAV;AACH;;AACD,gBAAMC,MAAM,GAAG;AACXJ,cAAAA,MAAM,EAANA,MADW;AAEXC,cAAAA,QAAQ,EAARA,QAFW;AAGXC,cAAAA,OAAO,EAAPA,OAHW;AAIXG,cAAAA,EAAE,EAAE,MAAKA;AAJE,aAAf;AAMA7E,YAAAA,OAAO;AAAA,qCAAO;AAEV8E,gBAAAA,MAAM,CAACC,yBAAP,CAAiCC,cAAjC,CAAgDV,GAAhD,EAAqDM,MAArD;AACH,eAHM;;AAAA;AAAA,qBAjJmBN,GAiJnB;AAAA,wBAjJwBM;AAiJxB;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA,gBAAP;AAIH;;AACD,cAAIP,GAAG,KAAK,MAAKV,UAAjB,EAA6B;AACzB,kBAAKA,UAAL,GAAkBU,GAAlB;AACH;AACJ;AAxCoC,OAAD,CAAxC;;AA0CA,YAAKY,YAAL,CAAkB,MAAKhE,KAAvB;;AACA,UAAIZ,MAAM,EAAV,EAAc;AACV,cAAKqD,aAAL,GAAqB;AAAEtC,UAAAA,KAAK,EAAE;AAAT,SAArB;AACH;;AACD,YAAKyD,EAAL,GAAU9E,WAAW,CAAC,EAAD,CAArB;AA5Ee;AA6ElB;;AAlF2D;AAAA;AAAA,aAmF5D,gCAAuB;AACnB,aAAKmF,kBAAL;;AACA,aAAKnB,cAAL,IAAuB,KAAKA,cAAL,CAAoBoB,QAApB,EAAvB;;AACA,aAAKC,mBAAL;;AACA,aAAKC,aAAL;;AACA,aAAKR,EAAL,GAAU,IAAV;AACH;AAzF2D;AAAA;AAAA,aA0F5D,6BAAoB;AAChB,YAAI,KAAKvB,mCAAT,EAA8C;AAC1C,eAAKA,mCAAL,GAA2C,KAA3C;;AACA,eAAKM,sBAAL;AACH;;AACD,aAAKG,cAAL,IAEI,KAAKA,cAAL,CAAoBuB,aAApB,CAAkC,KAAK3B,UAAvC,CAFJ;;AAGA,aAAK4B,mBAAL;;AACA,aAAKC,kBAAL;;AACA,aAAKC,qBAAL;AACH;AArG2D;AAAA;AAAA,aAsG5D,4BAAmB;AACf,YAAIC,EAAJ;;AAGA,eAAO,CAAC,CAACA,EAAE,GAAG,KAAK/B,UAAX,MAA2B,IAA3B,IAAmC+B,EAAE,KAAK,KAAK,CAA/C,GAAmD,KAAK,CAAxD,GAA4DA,EAAE,CAACC,iBAAhE,IAAqF,KAAKhC,UAAL,CAAgBgC,iBAAhB,EAArF,GACD,KAAKhC,UADX;AAEH;AA5G2D;AAAA;AAAA,aA6G5D,+BAAsB;AAClB,YAAMiC,IAAI,GAAG,KAAKC,gBAAL,EAAb;;AACA,YAAM9E,OAAO,GAAGwD,cAAc,CAAC,CAACrB,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAACW,cAA3D,IAA6E,IAA7E,GAAoF+B,IAArF,CAA9B;;AACA,aAAK,IAAMjE,GAAX,IAAkB,KAAKV,KAAvB,EAA8B;AAC1B,cAAM6E,IAAI,GAAG,KAAK7E,KAAL,CAAWU,GAAX,CAAb;;AACA,cAAImE,IAAI,YAAYxG,aAApB,EAAmC;AAC/BwG,YAAAA,IAAI,CAACC,WAAL,CAAiBH,IAAjB,EAAuBjE,GAAvB;AACH,WAFD,MAGK,IAAIkB,GAAG,CAAC,SAAD,EAAYiD,IAAZ,CAAH,IACLA,IAAI,CAACE,OAAL,YAAwBtG,mBADvB,EAC4C;AAC7CoG,YAAAA,IAAI,CAACE,OAAL,CAAaC,iBAAb,CAA+BlF,OAA/B,EAAwCY,GAAxC;AACH;AACJ;AACJ;AA1H2D;AAAA;AAAA,aA2H5D,+BAAsB;AAClB,YAAMiE,IAAI,GAAG,KAAKC,gBAAL,EAAb;;AACA,aAAK,IAAMlE,GAAX,IAAkB,KAAKV,KAAvB,EAA8B;AAC1B,cAAM6E,IAAI,GAAG,KAAK7E,KAAL,CAAWU,GAAX,CAAb;;AACA,cAAImE,IAAI,YAAYxG,aAApB,EAAmC;AAC/BwG,YAAAA,IAAI,CAACI,WAAL,CAAiBN,IAAjB,EAAuBjE,GAAvB;AACH,WAFD,MAGK,IAAIkB,GAAG,CAAC,SAAD,EAAYiD,IAAZ,CAAH,IACLA,IAAI,CAACE,OAAL,YAAwBtG,mBADvB,EAC4C;AAC7CoG,YAAAA,IAAI,CAACE,OAAL,CAAaG,oBAAb;AACH;AACJ;AACJ;AAvI2D;AAAA;AAAA,aAwI5D,yBAAgB;AACZ,YAAIT,EAAJ;;AACA,YAAIU,QAAQ,CAACC,EAAT,KAAgB,KAAhB,IAAyB,KAAK9C,OAAL,KAAiB,IAA9C,EAAoD;AAChD,+DAAoB,KAAKA,OAAzB,wCAAkC;AAAA,gBAAvBjB,KAAuB;;AAC9B,gBAAIA,KAAK,KAAK,IAAV,IAAkBA,KAAK,KAAK,KAAK,CAAjC,GAAqC,KAAK,CAA1C,GAA8CA,KAAK,CAACK,QAAxD,EAAkE;AAC9DL,cAAAA,KAAK,CAACK,QAAN,CAAe2D,MAAf,CAAsB,IAAtB;AACH;AACJ;AACJ,SAND,MAOK,IAAI,KAAK9C,QAAL,KAAkB,CAAC,CAAnB,IAAwB,KAAKD,OAAL,KAAiB,IAA7C,EAAmD;AACpD,gEAAoB,KAAKA,OAAzB,2CAAkC;AAAA,gBAAvBjB,MAAuB;;AAC9BA,YAAAA,MAAK,CAACC,eAAN,CAAsB+D,MAAtB,CAA6B,KAAK9C,QAAlC;AACH;;AACD,cAAI,CAACkC,EAAE,GAAG,KAAKzE,KAAL,CAAWsF,aAAjB,MAAoC,IAApC,IAA4Cb,EAAE,KAAK,KAAK,CAAxD,GAA4D,KAAK,CAAjE,GAAqEA,EAAE,CAACnD,eAA5E,EAA6F;AACzF,iBAAKtB,KAAL,CAAWsF,aAAX,CAAyBhE,eAAzB,CAAyC+D,MAAzC,CAAgD,KAAK9C,QAArD;AACH;AACJ;AACJ;AAzJ2D;AAAA;AAAA,aA0J5D,+BAAsBgD,SAAtB,EAAiC;AAC7B,YAAMZ,IAAI,GAAG,KAAKC,gBAAL,EAAb;;AACA,YAAMY,QAAQ,GAAG,IAAIC,GAAJ,EAAjB;AACA,YAAMC,QAAQ,GAAG,IAAID,GAAJ,EAAjB;AACA,YAAI3F,OAAJ;;AACA,aAAK,IAAMY,GAAX,IAAkB,KAAKV,KAAvB,EAA8B;AAC1B,cAAM6E,IAAI,GAAG,KAAK7E,KAAL,CAAWU,GAAX,CAAb;;AACA,cAAImE,IAAI,YAAYxG,aAApB,EAAmC;AAC/BqH,YAAAA,QAAQ,CAACC,GAAT,CAAad,IAAI,CAACe,QAAlB;AACH,WAFD,MAGK,IAAIhE,GAAG,CAAC,SAAD,EAAYiD,IAAZ,CAAH,IACLA,IAAI,CAACE,OAAL,YAAwBtG,mBADvB,EAC4C;AAC7C,gBAAIqB,OAAO,KAAKgC,SAAhB,EAA2B;AACvBhC,cAAAA,OAAO,GAAG+E,IAAI,CAACE,OAAL,CAAajF,OAAvB;AACH;AACJ;AACJ;;AACD,aAAK,IAAMY,IAAX,IAAkB6E,SAAlB,EAA6B;AACzB,cAAMV,KAAI,GAAG,KAAK7E,KAAL,CAAWU,IAAX,CAAb;;AACA,cAAImE,KAAI,YAAYxG,aAApB,EAAmC;AAC/B,gBAAI,CAACqH,QAAQ,CAAC9D,GAAT,CAAaiD,KAAI,CAACe,QAAlB,CAAL,EAAkC;AAE9Bf,cAAAA,KAAI,CAACI,WAAL,CAAiBN,IAAjB,EAAuBjE,IAAvB;AACH,aAHD,MAIK;AAED8E,cAAAA,QAAQ,CAACG,GAAT,CAAad,KAAI,CAACe,QAAlB;AACH;AACJ,WATD,MAUK,IAAIhE,GAAG,CAAC,SAAD,EAAYiD,KAAZ,CAAH,IACLA,KAAI,CAACE,OAAL,YAAwBtG,mBADnB,IAELoG,KAAI,CAACE,OAAL,CAAac,cAFZ,EAE4B;AAC7BhB,YAAAA,KAAI,CAACE,OAAL,CAAaG,oBAAb;AACH;AACJ;;AACD,aAAK,IAAMxE,KAAX,IAAkB,KAAKV,KAAvB,EAA8B;AAC1B,cAAM6E,MAAI,GAAG,KAAK7E,KAAL,CAAWU,KAAX,CAAb;;AACA,cAAImE,MAAI,YAAYxG,aAAhB,IACA,CAACmH,QAAQ,CAAC5D,GAAT,CAAaiD,MAAI,CAACe,QAAlB,CADL,EACkC;AAE9Bf,YAAAA,MAAI,CAACC,WAAL,CAAiBH,IAAjB,EAAuBjE,KAAvB;AACH,WAJD,MAKK,IAAIkB,GAAG,CAAC,SAAD,EAAYiD,MAAZ,CAAH,IACLA,MAAI,CAACE,OAAL,YAAwBtG,mBADnB,IAELoG,MAAI,CAACE,OAAL,CAAac,cAFZ,EAE4B;AAE7BhB,YAAAA,MAAI,CAACE,OAAL,CAAaC,iBAAb,CAA+BlF,OAA/B,EAAwCY,KAAxC;;AACAmE,YAAAA,MAAI,CAACE,OAAL,CAAac,cAAb,GAA8B,KAA9B;AACH;AACJ;AACJ;AA5M2D;AAAA;AAAA,aA6M5D,sBAAaC,SAAb,EAAwB;AACpB,YAAMC,gBAAgB,GAAG,KAAKjD,cAA9B;AACA,aAAKA,cAAL,GAAsBtE,sBAAsB,CAACsH,SAAD,EAAY,KAAKnD,sBAAjB,EAAyCoD,gBAAzC,CAA5C;;AAEA,YAAIA,gBAAgB,KAAK,KAAKjD,cAA9B,EAA8C;AAS1CiD,UAAAA,gBAAgB,IAAIA,gBAAgB,CAAC7B,QAAjB,EAApB;AACH;AACJ;AA5N2D;AAAA;AAAA,aA6N5D,2BAAkBlE,KAAlB,EAAyB;AACrB,YAAIyE,EAAJ,EAAQuB,EAAR;;AACA,YAAI/D,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAACW,cAA9D,EAA8E;AAE1EX,UAAAA,OAAO,CAACW,cAAR,CAAuB,KAAKF,UAA5B,EAAwC1C,KAAxC;AACH,SAHD,MAIK;AAED,WAACgG,EAAE,GAAG,CAACvB,EAAE,GAAG,KAAK/B,UAAX,MAA2B,IAA3B,IAAmC+B,EAAE,KAAK,KAAK,CAA/C,GAAmD,KAAK,CAAxD,GAA4DA,EAAE,CAAC7B,cAArE,MAAyF,IAAzF,IAAiGoD,EAAE,KAAK,KAAK,CAA7G,GAAiH,KAAK,CAAtH,GAA0HA,EAAE,CAACC,IAAH,CAAQxB,EAAR,EAAYzE,KAAZ,CAA1H;AACH;AACJ;AAvO2D;AAAA;AAAA,aAwO5D,8BAAqB;AACjB,YAAMF,OAAO,GAAGwD,cAAc,CAAC,IAAD,CAA9B;AACA9D,QAAAA,YAAY,CAAC0G,GAAb,CAAiBpG,OAAjB,EAA0B,IAA1B;;AACA,YAAIN,YAAY,CAAC2G,IAAb,KAAsB,CAA1B,EAA6B;AACzB/H,UAAAA,sBAAsB,CAACgI,WAAvB,CAAmC,yBAAnC,EAA8D1G,QAA9D;AACH;AACJ;AA9O2D;AAAA;AAAA,aA+O5D,iCAAwB;AAAA;;AACpB,YAAI+E,EAAJ,EAAQuB,EAAR,EAAYK,EAAZ;;AACA,YAAMlF,MAAM,GAAG,KAAKnB,KAAL,CAAWqB,KAAX,GACTH,kBAAkB,CAACP,YAAY,CAAC,KAAKX,KAAL,CAAWqB,KAAZ,CAAb,CADT,GAET,EAFN;AAGA,YAAMiF,UAAU,GAAG,KAAKhE,OAAxB;AACA,aAAKA,OAAL,GAAenB,MAAf;AACA,YAAMoF,iBAAiB,GAAG,KAAKC,cAA/B;AACA,aAAKA,cAAL,GAAsB,KAAKxG,KAAL,CAAWsF,aAAjC;AACA,YAAIxF,OAAJ;AACA,YAAI2G,QAAJ;;AACA,YAAItB,QAAQ,CAACC,EAAT,KAAgB,KAApB,EAA2B;AACvBtF,UAAAA,OAAO,GAAGwD,cAAc,CAAC,IAAD,CAAxB;AACAmD,UAAAA,QAAQ,GAAG,IAAX;AACH,SAHD,MAIK;AAED,cAAMC,YAAY,GAAG7H,UAAU,CAAC8H,2BAAX,CAAuC,IAAvC,CAArB;;AACA,cAAI,CAACD,YAAL,EAAmB;AACf,kBAAM,IAAIE,KAAJ,CAAU,yEAAV,CAAN;AACH;;AAED9G,UAAAA,OAAO,GAAG4G,YAAY,KAAK,IAAjB,IAAyBA,YAAY,KAAK,KAAK,CAA/C,GAAmD,KAAK,CAAxD,GAA4DA,YAAY,CAACG,UAAnF;AAKAJ,UAAAA,QAAQ,GAAG,CAAChC,EAAE,GAAGiC,YAAY,KAAK,IAAjB,IAAyBA,YAAY,KAAK,KAAK,CAA/C,GAAmD,KAAK,CAAxD,GAA4DA,YAAY,CAACI,UAA/E,MAA+F,IAA/F,IAAuGrC,EAAE,KAAK,KAAK,CAAnH,GAAuH,KAAK,CAA5H,GAAgIA,EAAE,CAACsC,eAA9I;AAEA,cAAMC,mBAAmB,GAAG,CAAC,CAAChB,EAAE,GAAG,KAAKhG,KAAL,CAAWsF,aAAjB,MAAoC,IAApC,IAA4CU,EAAE,KAAK,KAAK,CAAxD,GAA4D,KAAK,CAAjE,GAAqEA,EAAE,CAAC1E,eAAzE,KAA6FH,MAAM,CAAC8F,MAAhI;;AACA,cAAID,mBAAmB,KAAKN,YAAY,KAAK,IAAjB,IAAyBA,YAAY,KAAK,KAAK,CAA/C,GAAmD,KAAK,CAAxD,GAA4DA,YAAY,CAACI,UAA9E,CAAvB,EAAkH;AAC9GlI,YAAAA,eAAe,CAAC8H,YAAY,CAACI,UAAd,CAAf;AACH;AACJ;;AACD,aAAKvE,QAAL,GAAgBzC,OAAhB;;AAEA,YAAIwG,UAAJ,EAAgB;AAEZ,cAAMY,eAAe,GAAG/F,MAAM,CAAC8F,MAAP,KAAkB,CAAlB,IACpBX,UAAU,CAACW,MAAX,KAAsB,CADF,IAEpB1F,mBAAmB,CAACJ,MAAM,CAAC,CAAD,CAAP,EAAYmF,UAAU,CAAC,CAAD,CAAtB,CAFvB;;AAGA,cAAI,CAACY,eAAL,EAAsB;AAAA,uCAEPC,SAFO;AAGd,kBAAMC,SAAS,GAAGjG,MAAM,CAACb,IAAP,CAAY,UAACe,KAAD;AAAA,uBAAWE,mBAAmB,CAACF,KAAD,EAAQ8F,SAAR,CAA9B;AAAA,eAAZ,CAAlB;;AACA,kBAAI,CAACC,SAAL,EAAgB;AACZD,gBAAAA,SAAS,CAAC7F,eAAV,CAA0B+D,MAA1B,CAAiCvF,OAAjC;AACH;AANa;;AAElB,kEAAwBwG,UAAxB,2CAAoC;AAAA,kBAAzBa,SAAyB;;AAAA,oBAAzBA,SAAyB;AAKnC;AACJ;AACJ;;AACDhG,QAAAA,MAAM,CAACH,OAAP,CAAe,UAACK,KAAD,EAAW;AACtBA,UAAAA,KAAK,CAACC,eAAN,CAAsBqE,GAAtB,CAA0B;AAAEtC,YAAAA,GAAG,EAAEvD,OAAP;AAAgBuH,YAAAA,IAAI,EAAEZ;AAAtB,WAA1B;;AACA,cAAIrH,MAAM,EAAV,EAAc;AAOV,YAAA,MAAI,CAACqD,aAAL,CAAmBtC,KAAnB,GAA2B,SAAc,SAAc,EAAd,EAAkB,MAAI,CAACsC,aAAL,CAAmBtC,KAArC,CAAd,EAA2DkB,KAAK,CAACiG,OAAN,CAAcnH,KAAzE,CAA3B;AACAkB,YAAAA,KAAK,CAACoB,aAAN,CAAoBsC,OAApB,GAA8B,MAAI,CAACtC,aAAnC;AACH;AACJ,SAZD;;AAcA,YAAI8D,iBAAiB,IACjB,CAAC5E,mBAAmB,CAAC4E,iBAAD,EAAoB,KAAKvG,KAAL,CAAWsF,aAA/B,CADxB,EACuE;AACnEiB,UAAAA,iBAAiB,CAACjF,eAAlB,CAAkC+D,MAAlC,CAAyCvF,OAAzC;AACH;;AAED,YAAI,CAACuG,EAAE,GAAG,KAAKrG,KAAL,CAAWsF,aAAjB,MAAoC,IAApC,IAA4Ce,EAAE,KAAK,KAAK,CAAxD,GAA4D,KAAK,CAAjE,GAAqEA,EAAE,CAAC/E,eAA5E,EAA6F;AACzF,eAAKtB,KAAL,CAAWsF,aAAX,CAAyBhE,eAAzB,CAAyCqE,GAAzC,CAA6C;AAEzCtC,YAAAA,GAAG,EAAEvD,OAFoC;AAIzCuH,YAAAA,IAAI,EAAEZ;AAJmC,WAA7C;AAMH;AACJ;AA7T2D;AAAA;AAAA,aA8T5D,8BAAqB;AACjB,YAAM3G,OAAO,GAAGwD,cAAc,CAAC,IAAD,CAA9B;AACA9D,QAAAA,YAAY,CAAC+H,MAAb,CAAoBzH,OAApB;;AACA,YAAIN,YAAY,CAAC2G,IAAb,KAAsB,CAA1B,EAA6B;AACzB/H,UAAAA,sBAAsB,CAACoJ,kBAAvB,CAA0C,yBAA1C;AACH;AACJ;AApU2D;AAAA;AAAA,aAqU5D,4BAAmBjC,SAAnB,EAA8B;AAC1B,aAAKvB,YAAL,CAAkB,KAAKhE,KAAvB;;AACA,aAAKyH,qBAAL,CAA2BlC,SAA3B;;AACA,aAAKzC,cAAL,IAEI,KAAKA,cAAL,CAAoBuB,aAApB,CAAkC,KAAK3B,UAAvC,CAFJ;;AAGA,aAAK8B,qBAAL;AACH;AA5U2D;AAAA;AAAA,aA6U5D,iCAAwBkD,UAAxB,EAAoC;AAChC,YAAMrG,KAAK,GAAG,EAAd;;AACA,aAAK,IAAMX,GAAX,IAAkBgH,UAAlB,EAA8B;AAC1B,cAAMvH,KAAK,GAAGuH,UAAU,CAAChH,GAAD,CAAxB;;AACA,cAAI,CAACR,gBAAgB,CAACC,KAAD,CAArB,EAA8B;AAC1BkB,YAAAA,KAAK,CAACX,GAAD,CAAL,GAAaP,KAAb;AACH,WAFD,MAGK,IAAIA,KAAK,YAAY5B,aAArB,EAAoC;AAGrC8C,YAAAA,KAAK,CAACX,GAAD,CAAL,GAAaP,KAAK,CAACwH,cAAnB;AACH;AACJ;;AACD,eAAOtG,KAAP;AACH;AA3V2D;AAAA;AAAA,aA4V5D,iCAAwBuG,UAAxB,EAAoC;AAAA;;AAChC,YAAM5H,KAAK,GAAG,EAAd;;AADgC,qCAErBU,GAFqB;AAG5B,cAAMP,KAAK,GAAGyH,UAAU,CAAClH,GAAD,CAAxB;;AACA,cAAIA,GAAG,KAAK,OAAZ,EAAqB;AACjB,gBAAMmH,SAAS,GAAGD,UAAU,CAACvG,KAA7B;AACA,gBAAMF,MAAM,GAAGR,YAAY,CAACkH,SAAS,KAAK,IAAd,IAAsBA,SAAS,KAAK,KAAK,CAAzC,GAA6CA,SAA7C,GAAyD,EAA1D,CAA3B;AACA,gBAAMC,cAAc,GAAG3G,MAAM,CAAC4G,GAAP,CAAW,UAAC1G,KAAD,EAAW;AACzC,kBAAIA,KAAK,IAAIA,KAAK,CAACC,eAAnB,EAAoC;AAEhCD,gBAAAA,KAAK,CAACK,QAAN,CAAeiE,GAAf,CAAmB,MAAnB;;AACA,oBAAI,MAAI,CAACnD,cAAT,EAAyB;AACrB,yBAAO,SAAc,SAAc,EAAd,EAAkBnB,KAAK,CAACiG,OAAN,CAAcnH,KAAhC,CAAd,EAAsDZ,iBAAiB,CAAC8B,KAAK,CAACiG,OAAN,CAAcU,OAAf,CAAvE,CAAP;AACH,iBAFD,MAGK;AACD,yBAAO3G,KAAK,CAACiG,OAAN,CAAcnH,KAArB;AACH;AACJ,eATD,MAUK;AACD,uBAAOkB,KAAP;AACH;AACJ,aAdsB,CAAvB;AAeArB,YAAAA,KAAK,CAACU,GAAD,CAAL,GAAa,MAAI,CAACuH,uBAAL,CAA6BC,UAAU,CAACC,OAAX,CAAmBL,cAAnB,CAA7B,CAAb;AACH,WAnBD,MAoBK,IAAIpH,GAAG,KAAK,eAAZ,EAA6B;AAC9B,gBAAM0H,YAAY,GAAGR,UAAU,CAACtC,aAAhC;;AACA,gBAAI8C,YAAY,CAACd,OAAb,KAAyBxF,SAA7B,EAAwC;AACpCtB,cAAAA,MAAM,CAACC,IAAP,CAAY2H,YAAY,CAACd,OAAb,CAAqBnH,KAAjC,EAAwCa,OAAxC,CAAgD,UAACN,GAAD,EAAS;AACrD,oBAAI+D,EAAJ,EAAQuB,EAAR;;AACAhG,gBAAAA,KAAK,CAACU,GAAD,CAAL,GAAa,CAAC+D,EAAE,GAAG2D,YAAY,CAACd,OAAnB,MAAgC,IAAhC,IAAwC7C,EAAE,KAAK,KAAK,CAApD,GAAwD,KAAK,CAA7D,GAAiEA,EAAE,CAACtE,KAAH,CAASO,GAAT,CAA9E;AACA,iBAACsF,EAAE,GAAGoC,YAAY,CAAC1G,QAAnB,MAAiC,IAAjC,IAAyCsE,EAAE,KAAK,KAAK,CAArD,GAAyD,KAAK,CAA9D,GAAkEA,EAAE,CAACL,GAAH,CAAO,MAAP,CAAlE;AACH,eAJD;AAKH;AACJ,WATI,MAUA,IAAIxF,KAAK,YAAY9B,aAArB,EAAoC;AAKrC2B,YAAAA,KAAK,CAACU,GAAD,CAAL,GAAaT,aAAb;AACH,WANI,MAOA,IAAI2B,GAAG,CAAC,SAAD,EAAYzB,KAAZ,CAAH,IACLA,KAAK,CAAC4E,OAAN,YAAyBtG,mBADxB,EAC6C;AAC9C,gBAAI0B,KAAK,CAAC4E,OAAN,CAAcsD,UAAd,CAAyBpB,MAAzB,GAAkC,CAAtC,EAAyC;AACrC9G,cAAAA,KAAK,CAAC4E,OAAN,CAAcsD,UAAd,CAAyBrH,OAAzB,CAAiC,UAACsH,SAAD,EAAe;AAC5CtI,gBAAAA,KAAK,CAACsI,SAAD,CAAL,GAAmB1G,GAAG,CAAC,WAAD,EAAczB,KAAK,CAAC4E,OAApB,CAAH,GACb5E,KAAK,CAAC4E,OAAN,CAAcwD,SAAd,CAAwBD,SAAxB,CADa,GAEbrI,aAFN;AAGH,eAJD;AAKH,aAND,MAOK;AACDD,cAAAA,KAAK,CAACU,GAAD,CAAL,GAAaT,aAAb;AACH;AACJ,WAZI,MAaA,IAAI,EAAEE,KAAK,YAAY7B,YAAnB,CAAJ,EAAsC;AACvC,gBAAIoC,GAAG,KAAK,6BAAR,IAAyC,CAACrB,gBAAgB,EAA9D,EAAkE;AAC9DW,cAAAA,KAAK,CAACU,GAAD,CAAL,GAAaP,KAAb;AACH;AACJ,WAJI,MAKA,IAAIA,KAAK,YAAY5B,aAArB,EAAoC;AAGrCyB,YAAAA,KAAK,CAACU,GAAD,CAAL,GAAaP,KAAK,CAACwH,cAAnB;AACH;AA/D2B;;AAEhC,aAAK,IAAMjH,GAAX,IAAkBkH,UAAlB,EAA8B;AAAA,iBAAnBlH,GAAmB;AA8D7B;;AACD,eAAOV,KAAP;AACH;AA9Z2D;AAAA;AAAA,aA+Z5D,kBAAS;AACL,YAAMA,KAAK,GAAG,KAAKwI,uBAAL,CAA6B,KAAKxI,KAAlC,CAAd;;AACA,YAAIZ,MAAM,EAAV,EAAc;AACVY,UAAAA,KAAK,CAACyC,aAAN,GAAsB,KAAKA,aAA3B;AACH;;AACD,YAAI,KAAKD,cAAT,EAAyB;AACrB,eAAKA,cAAL,GAAsB,KAAtB;AACH;;AACD,YAAMiG,aAAa,GAAGtD,QAAQ,CAACuD,MAAT,CAAgB;AAClCC,UAAAA,GAAG,EAAE,EAD6B;AAElCC,UAAAA,OAAO,EAAE;AAAEC,YAAAA,WAAW,EAAE;AAAf;AAFyB,SAAhB,CAAtB;AAIA,eAAQ,KAAC,SAAD,kCAAe7I,KAAf;AAAsB,UAAA,GAAG,EAAE,KAAKgD;AAAhC,WAAsDyF,aAAtD,EAAR;AACH;AA5a2D;;AAAA;AAAA,IAIhCtK,KAAK,CAAC6D,SAJ0B;;AA8ahEI,EAAAA,iBAAiB,CAAC0G,WAAlB,2BAAqD9G,SAAS,CAAC8G,WAAV,IAAyB9G,SAAS,CAACqF,IAAnC,IAA2C,WAAhG;AACA,SAAOlJ,KAAK,CAAC4K,UAAN,CAAiB,UAAC/I,KAAD,EAAQoD,GAAR,EAAgB;AACpC,WAAQ,KAAC,iBAAD,kCAAuBpD,KAAvB,GAAmCoD,GAAG,KAAK,IAAR,GAAe,IAAf,GAAsB;AAAEF,MAAAA,YAAY,EAAEE;AAAhB,KAAzD,EAAR;AACH,GAFM,CAAP;AAGH","sourcesContent":["import React from 'react';\nimport { findNodeHandle, Platform, StyleSheet } from 'react-native';\nimport ReanimatedEventEmitter from './ReanimatedEventEmitter';\n// @ts-ignore JS file\nimport AnimatedEvent from './reanimated1/core/AnimatedEvent';\n// @ts-ignore JS file\nimport AnimatedNode from './reanimated1/core/AnimatedNode';\n// @ts-ignore JS file\nimport AnimatedValue from './reanimated1/core/AnimatedValue';\n// @ts-ignore JS file\nimport { createOrReusePropsNode } from './reanimated1/core/AnimatedProps';\nimport WorkletEventHandler from './reanimated2/WorkletEventHandler';\nimport setAndForwardRef from './setAndForwardRef';\nimport './reanimated2/layoutReanimation/LayoutAnimationRepository';\nimport invariant from 'invariant';\nimport { adaptViewConfig } from './ConfigHelper';\nimport { RNRenderer } from './reanimated2/platform-specific/RNRenderer';\nimport { makeMutable, runOnUI, enableLayoutAnimations, } from './reanimated2/core';\nimport { DefaultEntering, DefaultExiting, DefaultLayout, } from './reanimated2/layoutReanimation/defaultAnimations/Default';\nimport { isJest, isChromeDebugger, shouldBeUseWeb, } from './reanimated2/PlatformChecker';\nimport { initialUpdaterRun } from './reanimated2/animation';\nconst NODE_MAPPING = new Map();\nfunction listener(data) {\n    const component = NODE_MAPPING.get(data.viewTag);\n    component && component._updateFromNative(data.props);\n}\nfunction dummyListener() {\n    // empty listener we use to assign to listener properties for which animated\n    // event is used.\n}\nfunction hasAnimatedNodes(value) {\n    if (value instanceof AnimatedNode) {\n        return true;\n    }\n    if (Array.isArray(value)) {\n        return value.some((item) => hasAnimatedNodes(item));\n    }\n    if (value && typeof value === 'object') {\n        return Object.keys(value).some((key) => hasAnimatedNodes(value[key]));\n    }\n    return false;\n}\nfunction flattenArray(array) {\n    if (!Array.isArray(array)) {\n        return [array];\n    }\n    const resultArr = [];\n    const _flattenArray = (arr) => {\n        arr.forEach((item) => {\n            if (Array.isArray(item)) {\n                _flattenArray(item);\n            }\n            else {\n                resultArr.push(item);\n            }\n        });\n    };\n    _flattenArray(array);\n    return resultArr;\n}\nfunction onlyAnimatedStyles(styles) {\n    return styles.filter((style) => style === null || style === void 0 ? void 0 : style.viewDescriptors);\n}\nfunction isSameAnimatedStyle(style1, style2) {\n    // We cannot use equality check to compare useAnimatedStyle outputs directly.\n    // Instead, we can compare its viewsRefs.\n    return (style1 === null || style1 === void 0 ? void 0 : style1.viewsRef) === (style2 === null || style2 === void 0 ? void 0 : style2.viewsRef);\n}\nconst isSameAnimatedProps = isSameAnimatedStyle;\nconst has = (key, x) => {\n    if (typeof x === 'function' || typeof x === 'object') {\n        if (x === null || x === undefined) {\n            return false;\n        }\n        else {\n            return key in x;\n        }\n    }\n    return false;\n};\nexport default function createAnimatedComponent(Component, options) {\n    invariant(typeof Component !== 'function' ||\n        (Component.prototype && Component.prototype.isReactComponent), '`createAnimatedComponent` does not support stateless functional components; ' +\n        'use a class component instead.');\n    class AnimatedComponent extends React.Component {\n        constructor(props) {\n            super(props);\n            this._invokeAnimatedPropsCallbackOnMount = false;\n            this._styles = null;\n            this._viewTag = -1;\n            this._isFirstRender = true;\n            this.animatedStyle = { value: {} };\n            this._component = null;\n            // The system is best designed when setNativeProps is implemented. It is\n            // able to avoid re-rendering and directly set the attributes that changed.\n            // However, setNativeProps can only be implemented on native components\n            // If you want to animate a composite component, you need to re-render it.\n            // In this case, we have a fallback that uses forceUpdate.\n            this._animatedPropsCallback = () => {\n                if (this._component == null) {\n                    // AnimatedProps is created in will-mount because it's used in render.\n                    // But this callback may be invoked before mount in async mode,\n                    // In which case we should defer the setNativeProps() call.\n                    // React may throw away uncommitted work in async mode,\n                    // So a deferred call won't always be invoked.\n                    this._invokeAnimatedPropsCallbackOnMount = true;\n                }\n                else if (typeof this._component.setNativeProps !== 'function') {\n                    this.forceUpdate();\n                }\n                else {\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    this._component.setNativeProps(this._propsAnimated.__getValue());\n                }\n            };\n            this._setComponentRef = setAndForwardRef({\n                getForwardedRef: () => this.props.forwardedRef,\n                setLocalRef: (ref) => {\n                    // TODO update config\n                    const tag = findNodeHandle(ref);\n                    if ((this.props.layout || this.props.entering || this.props.exiting) &&\n                        tag != null) {\n                        if (!shouldBeUseWeb()) {\n                            enableLayoutAnimations(true, false);\n                        }\n                        let layout = this.props.layout ? this.props.layout : DefaultLayout;\n                        let entering = this.props.entering\n                            ? this.props.entering\n                            : DefaultEntering;\n                        let exiting = this.props.exiting\n                            ? this.props.exiting\n                            : DefaultExiting;\n                        if (has('build', layout)) {\n                            layout = layout.build();\n                        }\n                        if (has('build', entering)) {\n                            entering = entering.build();\n                        }\n                        if (has('build', exiting)) {\n                            exiting = exiting.build();\n                        }\n                        const config = {\n                            layout,\n                            entering,\n                            exiting,\n                            sv: this.sv,\n                        };\n                        runOnUI(() => {\n                            'worklet';\n                            global.LayoutAnimationRepository.registerConfig(tag, config);\n                        })();\n                    }\n                    if (ref !== this._component) {\n                        this._component = ref;\n                    }\n                },\n            });\n            this._attachProps(this.props);\n            if (isJest()) {\n                this.animatedStyle = { value: {} };\n            }\n            this.sv = makeMutable({});\n        }\n        componentWillUnmount() {\n            this._detachPropUpdater();\n            this._propsAnimated && this._propsAnimated.__detach();\n            this._detachNativeEvents();\n            this._detachStyles();\n            this.sv = null;\n        }\n        componentDidMount() {\n            if (this._invokeAnimatedPropsCallbackOnMount) {\n                this._invokeAnimatedPropsCallbackOnMount = false;\n                this._animatedPropsCallback();\n            }\n            this._propsAnimated &&\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                this._propsAnimated.setNativeView(this._component);\n            this._attachNativeEvents();\n            this._attachPropUpdater();\n            this._attachAnimatedStyles();\n        }\n        _getEventViewRef() {\n            var _a;\n            // Make sure to get the scrollable node for components that implement\n            // `ScrollResponder.Mixin`.\n            return ((_a = this._component) === null || _a === void 0 ? void 0 : _a.getScrollableNode) ? this._component.getScrollableNode()\n                : this._component;\n        }\n        _attachNativeEvents() {\n            const node = this._getEventViewRef();\n            const viewTag = findNodeHandle((options === null || options === void 0 ? void 0 : options.setNativeProps) ? this : node);\n            for (const key in this.props) {\n                const prop = this.props[key];\n                if (prop instanceof AnimatedEvent) {\n                    prop.attachEvent(node, key);\n                }\n                else if (has('current', prop) &&\n                    prop.current instanceof WorkletEventHandler) {\n                    prop.current.registerForEvents(viewTag, key);\n                }\n            }\n        }\n        _detachNativeEvents() {\n            const node = this._getEventViewRef();\n            for (const key in this.props) {\n                const prop = this.props[key];\n                if (prop instanceof AnimatedEvent) {\n                    prop.detachEvent(node, key);\n                }\n                else if (has('current', prop) &&\n                    prop.current instanceof WorkletEventHandler) {\n                    prop.current.unregisterFromEvents();\n                }\n            }\n        }\n        _detachStyles() {\n            var _a;\n            if (Platform.OS === 'web' && this._styles !== null) {\n                for (const style of this._styles) {\n                    if (style === null || style === void 0 ? void 0 : style.viewsRef) {\n                        style.viewsRef.remove(this);\n                    }\n                }\n            }\n            else if (this._viewTag !== -1 && this._styles !== null) {\n                for (const style of this._styles) {\n                    style.viewDescriptors.remove(this._viewTag);\n                }\n                if ((_a = this.props.animatedProps) === null || _a === void 0 ? void 0 : _a.viewDescriptors) {\n                    this.props.animatedProps.viewDescriptors.remove(this._viewTag);\n                }\n            }\n        }\n        _reattachNativeEvents(prevProps) {\n            const node = this._getEventViewRef();\n            const attached = new Set();\n            const nextEvts = new Set();\n            let viewTag;\n            for (const key in this.props) {\n                const prop = this.props[key];\n                if (prop instanceof AnimatedEvent) {\n                    nextEvts.add(prop.__nodeID);\n                }\n                else if (has('current', prop) &&\n                    prop.current instanceof WorkletEventHandler) {\n                    if (viewTag === undefined) {\n                        viewTag = prop.current.viewTag;\n                    }\n                }\n            }\n            for (const key in prevProps) {\n                const prop = this.props[key];\n                if (prop instanceof AnimatedEvent) {\n                    if (!nextEvts.has(prop.__nodeID)) {\n                        // event was in prev props but not in current props, we detach\n                        prop.detachEvent(node, key);\n                    }\n                    else {\n                        // event was in prev and is still in current props\n                        attached.add(prop.__nodeID);\n                    }\n                }\n                else if (has('current', prop) &&\n                    prop.current instanceof WorkletEventHandler &&\n                    prop.current.reattachNeeded) {\n                    prop.current.unregisterFromEvents();\n                }\n            }\n            for (const key in this.props) {\n                const prop = this.props[key];\n                if (prop instanceof AnimatedEvent &&\n                    !attached.has(prop.__nodeID)) {\n                    // not yet attached\n                    prop.attachEvent(node, key);\n                }\n                else if (has('current', prop) &&\n                    prop.current instanceof WorkletEventHandler &&\n                    prop.current.reattachNeeded) {\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    prop.current.registerForEvents(viewTag, key);\n                    prop.current.reattachNeeded = false;\n                }\n            }\n        }\n        _attachProps(nextProps) {\n            const oldPropsAnimated = this._propsAnimated;\n            this._propsAnimated = createOrReusePropsNode(nextProps, this._animatedPropsCallback, oldPropsAnimated);\n            // If prop node has been reused we don't need to call into \"__detach\"\n            if (oldPropsAnimated !== this._propsAnimated) {\n                // When you call detach, it removes the element from the parent list\n                // of children. If it goes to 0, then the parent also detaches itself\n                // and so on.\n                // An optimization is to attach the new elements and THEN detach the old\n                // ones instead of detaching and THEN attaching.\n                // This way the intermediate state isn't to go to 0 and trigger\n                // this expensive recursive detaching to then re-attach everything on\n                // the very next operation.\n                oldPropsAnimated && oldPropsAnimated.__detach();\n            }\n        }\n        _updateFromNative(props) {\n            var _a, _b;\n            if (options === null || options === void 0 ? void 0 : options.setNativeProps) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                options.setNativeProps(this._component, props);\n            }\n            else {\n                // eslint-disable-next-line no-unused-expressions\n                (_b = (_a = this._component) === null || _a === void 0 ? void 0 : _a.setNativeProps) === null || _b === void 0 ? void 0 : _b.call(_a, props);\n            }\n        }\n        _attachPropUpdater() {\n            const viewTag = findNodeHandle(this);\n            NODE_MAPPING.set(viewTag, this);\n            if (NODE_MAPPING.size === 1) {\n                ReanimatedEventEmitter.addListener('onReanimatedPropsChange', listener);\n            }\n        }\n        _attachAnimatedStyles() {\n            var _a, _b, _c;\n            const styles = this.props.style\n                ? onlyAnimatedStyles(flattenArray(this.props.style))\n                : [];\n            const prevStyles = this._styles;\n            this._styles = styles;\n            const prevAnimatedProps = this._animatedProps;\n            this._animatedProps = this.props.animatedProps;\n            let viewTag;\n            let viewName;\n            if (Platform.OS === 'web') {\n                viewTag = findNodeHandle(this);\n                viewName = null;\n            }\n            else {\n                // hostInstance can be null for a component that doesn't render anything (render function returns null). Example: svg Stop: https://github.com/react-native-svg/react-native-svg/blob/develop/src/elements/Stop.tsx\n                const hostInstance = RNRenderer.findHostInstance_DEPRECATED(this);\n                if (!hostInstance) {\n                    throw new Error('Cannot find host instance for this component. Maybe it renders nothing?');\n                }\n                // we can access view tag in the same way it's accessed here https://github.com/facebook/react/blob/e3f4eb7272d4ca0ee49f27577156b57eeb07cf73/packages/react-native-renderer/src/ReactFabric.js#L146\n                viewTag = hostInstance === null || hostInstance === void 0 ? void 0 : hostInstance._nativeTag;\n                /**\n                 * RN uses viewConfig for components for storing different properties of the component(example: https://github.com/facebook/react-native/blob/master/Libraries/Components/ScrollView/ScrollViewViewConfig.js#L16).\n                 * The name we're looking for is in the field named uiViewClassName.\n                 */\n                viewName = (_a = hostInstance === null || hostInstance === void 0 ? void 0 : hostInstance.viewConfig) === null || _a === void 0 ? void 0 : _a.uiViewClassName;\n                // update UI props whitelist for this view\n                const hasReanimated2Props = ((_b = this.props.animatedProps) === null || _b === void 0 ? void 0 : _b.viewDescriptors) || styles.length;\n                if (hasReanimated2Props && (hostInstance === null || hostInstance === void 0 ? void 0 : hostInstance.viewConfig)) {\n                    adaptViewConfig(hostInstance.viewConfig);\n                }\n            }\n            this._viewTag = viewTag;\n            // remove old styles\n            if (prevStyles) {\n                // in most of the cases, views have only a single animated style and it remains unchanged\n                const hasOneSameStyle = styles.length === 1 &&\n                    prevStyles.length === 1 &&\n                    isSameAnimatedStyle(styles[0], prevStyles[0]);\n                if (!hasOneSameStyle) {\n                    // otherwise, remove each style that is not present in new styles\n                    for (const prevStyle of prevStyles) {\n                        const isPresent = styles.some((style) => isSameAnimatedStyle(style, prevStyle));\n                        if (!isPresent) {\n                            prevStyle.viewDescriptors.remove(viewTag);\n                        }\n                    }\n                }\n            }\n            styles.forEach((style) => {\n                style.viewDescriptors.add({ tag: viewTag, name: viewName });\n                if (isJest()) {\n                    /**\n                     * We need to connect Jest's TestObject instance whose contains just props object\n                     * with the updateProps() function where we update the properties of the component.\n                     * We can't update props object directly because TestObject contains a copy of props - look at render function:\n                     * const props = this._filterNonAnimatedProps(this.props);\n                     */\n                    this.animatedStyle.value = Object.assign(Object.assign({}, this.animatedStyle.value), style.initial.value);\n                    style.animatedStyle.current = this.animatedStyle;\n                }\n            });\n            // detach old animatedProps\n            if (prevAnimatedProps &&\n                !isSameAnimatedProps(prevAnimatedProps, this.props.animatedProps)) {\n                prevAnimatedProps.viewDescriptors.remove(viewTag);\n            }\n            // attach animatedProps property\n            if ((_c = this.props.animatedProps) === null || _c === void 0 ? void 0 : _c.viewDescriptors) {\n                this.props.animatedProps.viewDescriptors.add({\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    tag: viewTag,\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    name: viewName,\n                });\n            }\n        }\n        _detachPropUpdater() {\n            const viewTag = findNodeHandle(this);\n            NODE_MAPPING.delete(viewTag);\n            if (NODE_MAPPING.size === 0) {\n                ReanimatedEventEmitter.removeAllListeners('onReanimatedPropsChange');\n            }\n        }\n        componentDidUpdate(prevProps) {\n            this._attachProps(this.props);\n            this._reattachNativeEvents(prevProps);\n            this._propsAnimated &&\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                this._propsAnimated.setNativeView(this._component);\n            this._attachAnimatedStyles();\n        }\n        _filterNonAnimatedStyle(inputStyle) {\n            const style = {};\n            for (const key in inputStyle) {\n                const value = inputStyle[key];\n                if (!hasAnimatedNodes(value)) {\n                    style[key] = value;\n                }\n                else if (value instanceof AnimatedValue) {\n                    // if any style in animated component is set directly to the `Value` we set those styles to the first value of `Value` node in order\n                    // to avoid flash of default styles when `Value` is being asynchrounously sent via bridge and initialized in the native side.\n                    style[key] = value._startingValue;\n                }\n            }\n            return style;\n        }\n        _filterNonAnimatedProps(inputProps) {\n            const props = {};\n            for (const key in inputProps) {\n                const value = inputProps[key];\n                if (key === 'style') {\n                    const styleProp = inputProps.style;\n                    const styles = flattenArray(styleProp !== null && styleProp !== void 0 ? styleProp : []);\n                    const processedStyle = styles.map((style) => {\n                        if (style && style.viewDescriptors) {\n                            // this is how we recognize styles returned by useAnimatedStyle\n                            style.viewsRef.add(this);\n                            if (this._isFirstRender) {\n                                return Object.assign(Object.assign({}, style.initial.value), initialUpdaterRun(style.initial.updater));\n                            }\n                            else {\n                                return style.initial.value;\n                            }\n                        }\n                        else {\n                            return style;\n                        }\n                    });\n                    props[key] = this._filterNonAnimatedStyle(StyleSheet.flatten(processedStyle));\n                }\n                else if (key === 'animatedProps') {\n                    const animatedProp = inputProps.animatedProps;\n                    if (animatedProp.initial !== undefined) {\n                        Object.keys(animatedProp.initial.value).forEach((key) => {\n                            var _a, _b;\n                            props[key] = (_a = animatedProp.initial) === null || _a === void 0 ? void 0 : _a.value[key];\n                            (_b = animatedProp.viewsRef) === null || _b === void 0 ? void 0 : _b.add(this);\n                        });\n                    }\n                }\n                else if (value instanceof AnimatedEvent) {\n                    // we cannot filter out event listeners completely as some components\n                    // rely on having a callback registered in order to generate events\n                    // alltogether. Therefore we provide a dummy callback here to allow\n                    // native event dispatcher to hijack events.\n                    props[key] = dummyListener;\n                }\n                else if (has('current', value) &&\n                    value.current instanceof WorkletEventHandler) {\n                    if (value.current.eventNames.length > 0) {\n                        value.current.eventNames.forEach((eventName) => {\n                            props[eventName] = has('listeners', value.current)\n                                ? value.current.listeners[eventName]\n                                : dummyListener;\n                        });\n                    }\n                    else {\n                        props[key] = dummyListener;\n                    }\n                }\n                else if (!(value instanceof AnimatedNode)) {\n                    if (key !== 'onGestureHandlerStateChange' || !isChromeDebugger()) {\n                        props[key] = value;\n                    }\n                }\n                else if (value instanceof AnimatedValue) {\n                    // if any prop in animated component is set directly to the `Value` we set those props to the first value of `Value` node in order\n                    // to avoid default values for a short moment when `Value` is being asynchrounously sent via bridge and initialized in the native side.\n                    props[key] = value._startingValue;\n                }\n            }\n            return props;\n        }\n        render() {\n            const props = this._filterNonAnimatedProps(this.props);\n            if (isJest()) {\n                props.animatedStyle = this.animatedStyle;\n            }\n            if (this._isFirstRender) {\n                this._isFirstRender = false;\n            }\n            const platformProps = Platform.select({\n                web: {},\n                default: { collapsable: false },\n            });\n            return (<Component {...props} ref={this._setComponentRef} {...platformProps}/>);\n        }\n    }\n    AnimatedComponent.displayName = `AnimatedComponent(${Component.displayName || Component.name || 'Component'})`;\n    return React.forwardRef((props, ref) => {\n        return (<AnimatedComponent {...props} {...(ref === null ? null : { forwardedRef: ref })}/>);\n    });\n}\n"]},"metadata":{},"sourceType":"module"}