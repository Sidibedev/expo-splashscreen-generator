{"ast":null,"code":"import _createClass from \"@babel/runtime/helpers/createClass\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\n\nvar Point = _createClass(function Point(x, y) {\n  _classCallCheck(this, Point);\n\n  this.x = x;\n  this.y = y;\n});\n\nvar Size = _createClass(function Size(width, height) {\n  _classCallCheck(this, Size);\n\n  this.width = width;\n  this.height = height;\n});\n\nvar Rect = _createClass(function Rect(x, y, width, height) {\n  _classCallCheck(this, Rect);\n\n  this.x = x;\n  this.y = y;\n  this.width = width;\n  this.height = height;\n});\n\nvar swapSizeDimmensions = function swapSizeDimmensions(size) {\n  return new Size(size.height, size.width);\n};\n\nvar makeChildlessRect = function makeChildlessRect(_ref) {\n  var displayInsets = _ref.displayInsets,\n      windowDims = _ref.windowDims,\n      placement = _ref.placement;\n\n  switch (placement) {\n    case 'bottom':\n      return new Rect(windowDims.width / 2, displayInsets.top, 1, 1);\n\n    case 'right':\n      return new Rect(displayInsets.left, windowDims.height / 2, 1, 1);\n\n    case 'left':\n      return new Rect(windowDims.width - displayInsets.right, windowDims.height / 2, 1, 1);\n\n    case 'top':\n    default:\n      return new Rect(windowDims.width / 2, windowDims.height - displayInsets.bottom, 1, 1);\n  }\n};\n\nvar computeCenterGeometry = function computeCenterGeometry(_ref2) {\n  var childRect = _ref2.childRect,\n      contentSize = _ref2.contentSize,\n      displayInsets = _ref2.displayInsets,\n      windowDims = _ref2.windowDims;\n  var maxWidth = windowDims.width - (displayInsets.left + displayInsets.right);\n  var maxHeight = windowDims.height - (displayInsets.top + displayInsets.bottom);\n  var adjustedContentSize = new Size(contentSize.width >= maxWidth ? maxWidth : -1, contentSize.height >= maxHeight ? maxHeight : -1);\n  var tooltipOrigin = new Point(adjustedContentSize.width === -1 ? (maxWidth - contentSize.width) / 2 + displayInsets.left : displayInsets.left, adjustedContentSize.height === -1 ? (maxHeight - contentSize.height) / 2 + displayInsets.top : displayInsets.top);\n  var anchorPoint = new Point(childRect.x + childRect.width / 2.0, childRect.y);\n  return {\n    tooltipOrigin: tooltipOrigin,\n    anchorPoint: anchorPoint,\n    placement: 'center',\n    adjustedContentSize: adjustedContentSize\n  };\n};\n\nvar computeTopGeometry = function computeTopGeometry(_ref3) {\n  var childRect = _ref3.childRect,\n      contentSize = _ref3.contentSize,\n      arrowSize = _ref3.arrowSize,\n      displayInsets = _ref3.displayInsets,\n      windowDims = _ref3.windowDims,\n      childContentSpacing = _ref3.childContentSpacing;\n  var maxWidth = windowDims.width - (displayInsets.left + displayInsets.right);\n  var adjustedContentSize = new Size(Math.min(maxWidth, contentSize.width), contentSize.height);\n  var tooltipOrigin = new Point(contentSize.width >= maxWidth ? displayInsets.left : Math.max(displayInsets.left, childRect.x + (childRect.width - adjustedContentSize.width) / 2), Math.max(displayInsets.top - childContentSpacing, childRect.y - contentSize.height - arrowSize.height - childContentSpacing));\n  var anchorPoint = new Point(childRect.x + childRect.width / 2.0, childRect.y - childContentSpacing);\n\n  if (anchorPoint.x + arrowSize.width > windowDims.width - displayInsets.right) {\n    anchorPoint.x = windowDims.width - displayInsets.right - Math.abs(arrowSize.width - arrowSize.height) - 8;\n  } else if (anchorPoint.x - arrowSize.width < displayInsets.left) {\n    anchorPoint.x = displayInsets.left + Math.abs(arrowSize.width - arrowSize.height) + 8;\n  }\n\n  var topPlacementBottomBound = anchorPoint.y - arrowSize.height;\n\n  if (tooltipOrigin.y + contentSize.height > topPlacementBottomBound) {\n    adjustedContentSize.height = topPlacementBottomBound - tooltipOrigin.y;\n  }\n\n  if (tooltipOrigin.x + contentSize.width > maxWidth) {\n    tooltipOrigin.x = windowDims.width - displayInsets.right - adjustedContentSize.width;\n  }\n\n  return {\n    tooltipOrigin: tooltipOrigin,\n    anchorPoint: anchorPoint,\n    placement: 'top',\n    adjustedContentSize: adjustedContentSize\n  };\n};\n\nvar computeBottomGeometry = function computeBottomGeometry(_ref4) {\n  var childRect = _ref4.childRect,\n      contentSize = _ref4.contentSize,\n      arrowSize = _ref4.arrowSize,\n      displayInsets = _ref4.displayInsets,\n      windowDims = _ref4.windowDims,\n      childContentSpacing = _ref4.childContentSpacing;\n  var maxWidth = windowDims.width - (displayInsets.left + displayInsets.right);\n  var adjustedContentSize = new Size(Math.min(maxWidth, contentSize.width), contentSize.height);\n  var tooltipOrigin = new Point(contentSize.width >= maxWidth ? displayInsets.left : Math.max(displayInsets.left, childRect.x + (childRect.width - adjustedContentSize.width) / 2), Math.min(windowDims.height - displayInsets.bottom + childContentSpacing, childRect.y + childRect.height + arrowSize.height + childContentSpacing));\n  var anchorPoint = new Point(childRect.x + childRect.width / 2.0, childRect.y + childRect.height + childContentSpacing);\n\n  if (anchorPoint.x + arrowSize.width > windowDims.width - displayInsets.right) {\n    anchorPoint.x = windowDims.width - displayInsets.right - Math.abs(arrowSize.width - arrowSize.height) - 8;\n  } else if (anchorPoint.x - arrowSize.width < displayInsets.left) {\n    anchorPoint.x = displayInsets.left + Math.abs(arrowSize.width - arrowSize.height) + 8;\n  }\n\n  if (tooltipOrigin.y + contentSize.height > windowDims.height - displayInsets.bottom) {\n    adjustedContentSize.height = windowDims.height - displayInsets.bottom - tooltipOrigin.y;\n  }\n\n  if (tooltipOrigin.x + contentSize.width > maxWidth) {\n    tooltipOrigin.x = windowDims.width - displayInsets.right - adjustedContentSize.width;\n  }\n\n  return {\n    tooltipOrigin: tooltipOrigin,\n    anchorPoint: anchorPoint,\n    placement: 'bottom',\n    adjustedContentSize: adjustedContentSize\n  };\n};\n\nvar computeLeftGeometry = function computeLeftGeometry(_ref5) {\n  var childRect = _ref5.childRect,\n      contentSize = _ref5.contentSize,\n      arrowSize = _ref5.arrowSize,\n      displayInsets = _ref5.displayInsets,\n      windowDims = _ref5.windowDims,\n      childContentSpacing = _ref5.childContentSpacing;\n  var maxHeight = windowDims.height - (displayInsets.top + displayInsets.bottom);\n  var adjustedContentSize = new Size(contentSize.width, Math.min(maxHeight, contentSize.height));\n  var tooltipOrigin = new Point(Math.max(displayInsets.left - childContentSpacing, childRect.x - contentSize.width - arrowSize.width - childContentSpacing), contentSize.height >= maxHeight ? displayInsets.top : Math.max(displayInsets.top, childRect.y + (childRect.height - adjustedContentSize.height) / 2));\n  var anchorPoint = new Point(childRect.x - childContentSpacing, childRect.y + childRect.height / 2.0);\n\n  if (anchorPoint.y + arrowSize.width > windowDims.height - displayInsets.bottom) {\n    anchorPoint.y = windowDims.height - displayInsets.bottom - Math.abs(arrowSize.height - arrowSize.width) - 8;\n  } else if (anchorPoint.y - arrowSize.height < displayInsets.top) {\n    anchorPoint.y = displayInsets.top + Math.abs(arrowSize.height - arrowSize.width) + 8;\n  }\n\n  var leftPlacementRightBound = anchorPoint.x - arrowSize.width;\n\n  if (tooltipOrigin.x + contentSize.width > leftPlacementRightBound) {\n    adjustedContentSize.width = leftPlacementRightBound - tooltipOrigin.x;\n  }\n\n  if (tooltipOrigin.y + contentSize.height > maxHeight) {\n    tooltipOrigin.y = windowDims.height - displayInsets.bottom - adjustedContentSize.height;\n  }\n\n  return {\n    tooltipOrigin: tooltipOrigin,\n    anchorPoint: anchorPoint,\n    placement: 'left',\n    adjustedContentSize: adjustedContentSize\n  };\n};\n\nvar computeRightGeometry = function computeRightGeometry(_ref6) {\n  var childRect = _ref6.childRect,\n      contentSize = _ref6.contentSize,\n      arrowSize = _ref6.arrowSize,\n      displayInsets = _ref6.displayInsets,\n      windowDims = _ref6.windowDims,\n      childContentSpacing = _ref6.childContentSpacing;\n  var maxHeight = windowDims.height - (displayInsets.top + displayInsets.bottom);\n  var adjustedContentSize = new Size(contentSize.width, Math.min(maxHeight, contentSize.height));\n  var tooltipOrigin = new Point(Math.min(windowDims.width - displayInsets.right + childContentSpacing, childRect.x + childRect.width + arrowSize.width + childContentSpacing), contentSize.height >= maxHeight ? displayInsets.top : Math.max(displayInsets.top, childRect.y + (childRect.height - adjustedContentSize.height) / 2));\n  var anchorPoint = new Point(childRect.x + childRect.width + childContentSpacing, childRect.y + childRect.height / 2.0);\n\n  if (anchorPoint.y + arrowSize.width > windowDims.height - displayInsets.bottom) {\n    anchorPoint.y = windowDims.height - displayInsets.bottom - Math.abs(arrowSize.height - arrowSize.width) - 8;\n  } else if (anchorPoint.y - arrowSize.height < displayInsets.top) {\n    anchorPoint.y = displayInsets.top + Math.abs(arrowSize.height - arrowSize.width) + 8;\n  }\n\n  if (tooltipOrigin.x + contentSize.width > windowDims.width - displayInsets.right) {\n    adjustedContentSize.width = windowDims.width - displayInsets.right - tooltipOrigin.x;\n  }\n\n  if (tooltipOrigin.y + contentSize.height > maxHeight) {\n    tooltipOrigin.y = windowDims.height - displayInsets.bottom - adjustedContentSize.height;\n  }\n\n  return {\n    tooltipOrigin: tooltipOrigin,\n    anchorPoint: anchorPoint,\n    placement: 'right',\n    adjustedContentSize: adjustedContentSize\n  };\n};\n\nexport { Point, Size, Rect, swapSizeDimmensions, makeChildlessRect, computeCenterGeometry, computeTopGeometry, computeBottomGeometry, computeLeftGeometry, computeRightGeometry };","map":{"version":3,"sources":["/Users/mas/Documents/perso/expo-splashscreen-generator/node_modules/react-native-walkthrough-tooltip/src/geom.js"],"names":["Point","x","y","Size","width","height","Rect","swapSizeDimmensions","size","makeChildlessRect","displayInsets","windowDims","placement","top","left","right","bottom","computeCenterGeometry","childRect","contentSize","maxWidth","maxHeight","adjustedContentSize","tooltipOrigin","anchorPoint","computeTopGeometry","arrowSize","childContentSpacing","Math","min","max","abs","topPlacementBottomBound","computeBottomGeometry","computeLeftGeometry","leftPlacementRightBound","computeRightGeometry"],"mappings":"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","sourcesContent":["class Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n}\n\nclass Size {\n  constructor(width, height) {\n    this.width = width;\n    this.height = height;\n  }\n}\n\nclass Rect {\n  constructor(x, y, width, height) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n  }\n}\n\nconst swapSizeDimmensions = size => new Size(size.height, size.width);\n\nconst makeChildlessRect = ({ displayInsets, windowDims, placement }) => {\n  switch (placement) {\n    case 'bottom':\n      return new Rect(windowDims.width / 2, displayInsets.top, 1, 1);\n\n    case 'right':\n      return new Rect(displayInsets.left, windowDims.height / 2, 1, 1);\n\n    case 'left':\n      return new Rect(\n        windowDims.width - displayInsets.right,\n        windowDims.height / 2,\n        1,\n        1,\n      );\n    case 'top':\n    default:\n      return new Rect(\n        windowDims.width / 2,\n        windowDims.height - displayInsets.bottom,\n        1,\n        1,\n      );\n  }\n};\n\nconst computeCenterGeometry = ({\n  childRect,\n  contentSize,\n  displayInsets,\n  windowDims,\n}) => {\n  const maxWidth =\n    windowDims.width - (displayInsets.left + displayInsets.right);\n  const maxHeight =\n    windowDims.height - (displayInsets.top + displayInsets.bottom);\n\n  const adjustedContentSize = new Size(\n    contentSize.width >= maxWidth ? maxWidth : -1,\n    contentSize.height >= maxHeight ? maxHeight : -1,\n  );\n\n  const tooltipOrigin = new Point(\n    adjustedContentSize.width === -1\n      ? (maxWidth - contentSize.width) / 2 + displayInsets.left\n      : displayInsets.left,\n    adjustedContentSize.height === -1\n      ? (maxHeight - contentSize.height) / 2 + displayInsets.top\n      : displayInsets.top,\n  );\n\n  const anchorPoint = new Point(\n    childRect.x + childRect.width / 2.0,\n    childRect.y,\n  );\n\n  return {\n    tooltipOrigin,\n    anchorPoint,\n    placement: 'center',\n    adjustedContentSize,\n  };\n};\n\nconst computeTopGeometry = ({\n  childRect,\n  contentSize,\n  arrowSize,\n  displayInsets,\n  windowDims,\n  childContentSpacing,\n}) => {\n  const maxWidth =\n    windowDims.width - (displayInsets.left + displayInsets.right);\n\n  const adjustedContentSize = new Size(\n    Math.min(maxWidth, contentSize.width),\n    contentSize.height,\n  );\n\n  const tooltipOrigin = new Point(\n    contentSize.width >= maxWidth\n      ? displayInsets.left\n      : Math.max(\n          displayInsets.left,\n          childRect.x + (childRect.width - adjustedContentSize.width) / 2,\n        ),\n    Math.max(\n      displayInsets.top - childContentSpacing,\n      childRect.y - contentSize.height - arrowSize.height - childContentSpacing,\n    ),\n  );\n\n  const anchorPoint = new Point(\n    childRect.x + childRect.width / 2.0,\n    childRect.y - childContentSpacing,\n  );\n\n  // make sure arrow does not extend beyond displayInsets\n  if (\n    anchorPoint.x + arrowSize.width >\n    windowDims.width - displayInsets.right\n  ) {\n    anchorPoint.x =\n      windowDims.width -\n      displayInsets.right -\n      Math.abs(arrowSize.width - arrowSize.height) -\n      8;\n  } else if (anchorPoint.x - arrowSize.width < displayInsets.left) {\n    anchorPoint.x =\n      displayInsets.left + Math.abs(arrowSize.width - arrowSize.height) + 8;\n  }\n\n  const topPlacementBottomBound = anchorPoint.y - arrowSize.height;\n\n  if (tooltipOrigin.y + contentSize.height > topPlacementBottomBound) {\n    adjustedContentSize.height = topPlacementBottomBound - tooltipOrigin.y;\n  }\n\n  if (tooltipOrigin.x + contentSize.width > maxWidth) {\n    tooltipOrigin.x =\n      windowDims.width - displayInsets.right - adjustedContentSize.width;\n  }\n\n  return {\n    tooltipOrigin,\n    anchorPoint,\n    placement: 'top',\n    adjustedContentSize,\n  };\n};\n\nconst computeBottomGeometry = ({\n  childRect,\n  contentSize,\n  arrowSize,\n  displayInsets,\n  windowDims,\n  childContentSpacing,\n}) => {\n  const maxWidth =\n    windowDims.width - (displayInsets.left + displayInsets.right);\n\n  const adjustedContentSize = new Size(\n    Math.min(maxWidth, contentSize.width),\n    contentSize.height,\n  );\n\n  const tooltipOrigin = new Point(\n    contentSize.width >= maxWidth\n      ? displayInsets.left\n      : Math.max(\n          displayInsets.left,\n          childRect.x + (childRect.width - adjustedContentSize.width) / 2,\n        ),\n    Math.min(\n      windowDims.height - displayInsets.bottom + childContentSpacing,\n      childRect.y + childRect.height + arrowSize.height + childContentSpacing,\n    ),\n  );\n  const anchorPoint = new Point(\n    childRect.x + childRect.width / 2.0,\n    childRect.y + childRect.height + childContentSpacing,\n  );\n\n  // make sure arrow does not extend beyond displayInsets\n  if (\n    anchorPoint.x + arrowSize.width >\n    windowDims.width - displayInsets.right\n  ) {\n    anchorPoint.x =\n      windowDims.width -\n      displayInsets.right -\n      Math.abs(arrowSize.width - arrowSize.height) -\n      8;\n  } else if (anchorPoint.x - arrowSize.width < displayInsets.left) {\n    anchorPoint.x =\n      displayInsets.left + Math.abs(arrowSize.width - arrowSize.height) + 8;\n  }\n\n  if (\n    tooltipOrigin.y + contentSize.height >\n    windowDims.height - displayInsets.bottom\n  ) {\n    adjustedContentSize.height =\n      windowDims.height - displayInsets.bottom - tooltipOrigin.y;\n  }\n\n  if (tooltipOrigin.x + contentSize.width > maxWidth) {\n    tooltipOrigin.x =\n      windowDims.width - displayInsets.right - adjustedContentSize.width;\n  }\n\n  return {\n    tooltipOrigin,\n    anchorPoint,\n    placement: 'bottom',\n    adjustedContentSize,\n  };\n};\n\nconst computeLeftGeometry = ({\n  childRect,\n  contentSize,\n  arrowSize,\n  displayInsets,\n  windowDims,\n  childContentSpacing,\n}) => {\n  const maxHeight =\n    windowDims.height - (displayInsets.top + displayInsets.bottom);\n\n  const adjustedContentSize = new Size(\n    contentSize.width,\n    Math.min(maxHeight, contentSize.height),\n  );\n\n  const tooltipOrigin = new Point(\n    Math.max(\n      displayInsets.left - childContentSpacing,\n      childRect.x - contentSize.width - arrowSize.width - childContentSpacing,\n    ),\n    contentSize.height >= maxHeight\n      ? displayInsets.top\n      : Math.max(\n          displayInsets.top,\n          childRect.y + (childRect.height - adjustedContentSize.height) / 2,\n        ),\n  );\n\n  const anchorPoint = new Point(\n    childRect.x - childContentSpacing,\n    childRect.y + childRect.height / 2.0,\n  );\n\n  // make sure arrow does not extend beyond displayInsets\n  if (\n    anchorPoint.y + arrowSize.width >\n    windowDims.height - displayInsets.bottom\n  ) {\n    anchorPoint.y =\n      windowDims.height -\n      displayInsets.bottom -\n      Math.abs(arrowSize.height - arrowSize.width) -\n      8;\n  } else if (anchorPoint.y - arrowSize.height < displayInsets.top) {\n    anchorPoint.y =\n      displayInsets.top + Math.abs(arrowSize.height - arrowSize.width) + 8;\n  }\n\n  const leftPlacementRightBound = anchorPoint.x - arrowSize.width;\n\n  if (tooltipOrigin.x + contentSize.width > leftPlacementRightBound) {\n    adjustedContentSize.width = leftPlacementRightBound - tooltipOrigin.x;\n  }\n\n  if (tooltipOrigin.y + contentSize.height > maxHeight) {\n    tooltipOrigin.y =\n      windowDims.height - displayInsets.bottom - adjustedContentSize.height;\n  }\n\n  return {\n    tooltipOrigin,\n    anchorPoint,\n    placement: 'left',\n    adjustedContentSize,\n  };\n};\n\nconst computeRightGeometry = ({\n  childRect,\n  contentSize,\n  arrowSize,\n  displayInsets,\n  windowDims,\n  childContentSpacing,\n}) => {\n  const maxHeight =\n    windowDims.height - (displayInsets.top + displayInsets.bottom);\n\n  const adjustedContentSize = new Size(\n    contentSize.width,\n    Math.min(maxHeight, contentSize.height),\n  );\n\n  const tooltipOrigin = new Point(\n    Math.min(\n      windowDims.width - displayInsets.right + childContentSpacing,\n      childRect.x + childRect.width + arrowSize.width + childContentSpacing,\n    ),\n    contentSize.height >= maxHeight\n      ? displayInsets.top\n      : Math.max(\n          displayInsets.top,\n          childRect.y + (childRect.height - adjustedContentSize.height) / 2,\n        ),\n  );\n\n  const anchorPoint = new Point(\n    childRect.x + childRect.width + childContentSpacing,\n    childRect.y + childRect.height / 2.0,\n  );\n\n  // make sure arrow does not extend beyond displayInsets\n  if (\n    anchorPoint.y + arrowSize.width >\n    windowDims.height - displayInsets.bottom\n  ) {\n    anchorPoint.y =\n      windowDims.height -\n      displayInsets.bottom -\n      Math.abs(arrowSize.height - arrowSize.width) -\n      8;\n  } else if (anchorPoint.y - arrowSize.height < displayInsets.top) {\n    anchorPoint.y =\n      displayInsets.top + Math.abs(arrowSize.height - arrowSize.width) + 8;\n  }\n\n  if (\n    tooltipOrigin.x + contentSize.width >\n    windowDims.width - displayInsets.right\n  ) {\n    adjustedContentSize.width =\n      windowDims.width - displayInsets.right - tooltipOrigin.x;\n  }\n\n  if (tooltipOrigin.y + contentSize.height > maxHeight) {\n    tooltipOrigin.y =\n      windowDims.height - displayInsets.bottom - adjustedContentSize.height;\n  }\n\n  return {\n    tooltipOrigin,\n    anchorPoint,\n    placement: 'right',\n    adjustedContentSize,\n  };\n};\n\nexport {\n  Point,\n  Size,\n  Rect,\n  swapSizeDimmensions,\n  makeChildlessRect,\n  computeCenterGeometry,\n  computeTopGeometry,\n  computeBottomGeometry,\n  computeLeftGeometry,\n  computeRightGeometry,\n};\n"]},"metadata":{},"sourceType":"module"}